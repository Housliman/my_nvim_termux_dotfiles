// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/queue.go:1:1
// Copyright 2019, 2023 The Godror Authors
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package godror

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"runtime"
	"sync"
	"time"
	"unsafe"
)

const MsgIDLength = 16

var zeroMsgID [MsgIDLength]byte

// DefaultEnqOptions is the default set for NewQueue.
var DefaultEnqOptions = EnqOptions{
	Visibility:   VisibleOnCommit,
	DeliveryMode: DeliverPersistent,
}

// DefaultDeqOptions is the default set for NewQueue.
var DefaultDeqOptions = DeqOptions{
	Mode:         DeqRemove,
	DeliveryMode: DeliverPersistent,
	Navigation:   NavNext,
	Visibility:   VisibleOnCommit,
	Wait:         0,
}

// Queue represents an Oracle Advanced Queue.
type Queue struct {
	PayloadObjectType *ObjectType
	conn              *conn
	dpiQueue          * /*line :47:21*/_Ctype_dpiQueue /*line :47:31*/
	name              string
	props             []* /*line :49:23*/_Ctype_dpiMsgProps /*line :49:36*/
	mu                sync.Mutex
	connIsOwned       bool
}

type queueOption interface{ qOption() }

// WithDeqOptions returns a queueOption usable in NewQueue, applying the given DeqOptions.
func WithDeqOptions(o DeqOptions) queueOption { return o }

// WithEnqOptions returns a queueOption usable in NewQueue, applying the given EnqOptions.
func WithEnqOptions(o EnqOptions) queueOption { return o }

// NewQueue creates a new Queue.
//
// WARNING: the connection given to it must not be closed before the Queue is closed!
// So use an sql.Conn for it.
func NewQueue(ctx context.Context, execer Execer, name string, payloadObjectTypeName string, options ...queueOption) (*Queue, error) {
	cx, err := DriverConn(ctx, execer)
	if err != nil {
		return nil, err
	}
	// Check whether this is a pool or a single connection.
	cx2, err := DriverConn(ctx, execer)
	if err != nil {
		cx.Close()
		return nil, err
	}
	//fmt.Printf("cx=%p cx2=%p\n", cx.(*conn).dpiConn, cx2.(*conn).dpiConn)
	owned := cx.(*conn).dpiConn != cx2.(*conn).dpiConn
	if owned {
		cx2.Close()
	}
	Q := Queue{conn: cx.(*conn), name: name, connIsOwned: owned}

	var payloadType * /*line :84:19*/_Ctype_dpiObjectType /*line :84:34*/
	if payloadObjectTypeName != "" {
		ot, err := Q.conn.GetObjectType(payloadObjectTypeName)
		if err != nil {
			return nil, err
		}
		Q.PayloadObjectType, payloadType = ot, ot.dpiObjectType
	}
	value := ( /*line :92:11*/_Cfunc_CString /*line :92:19*/)(name)
	err = Q.conn.checkExec(func()  /*line :93:32*/_Ctype_int /*line :93:37*/ {
		return func() _Ctype_int{ _cgo0 := /*line :94:29*/Q.conn.dpiConn; var _cgo1 *_Ctype_char = /*line :94:45*/value; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :94:58*/(len(name)); _cgo3 := /*line :94:71*/payloadType; _cgoBase4 := /*line :94:84*/&Q.dpiQueue; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :94:96*/_Cfunc_dpiConn_newQueue(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	})
	func() { _cgo0 := /*line :96:9*/unsafe.Pointer(value); _cgoCheckPointer(_cgo0, nil); /*line :96:31*/_Cfunc_free(_cgo0); }()
	if err != nil {
		cx.Close()
		return nil, fmt.Errorf("newQueue %q: %w", name, err)
	}

	if guardWithFinalizers.Load() {
		if !logLingeringResourceStack.Load() {
			runtime.SetFinalizer(&Q, func(Q *Queue) {
				if Q != nil && Q.dpiQueue != nil {
					fmt.Printf("ERROR: queue %p of NewQueue is not Closed!\n", Q)
					Q.Close()
				}
			})
		} else {
			var a [4096]byte
			stack := a[:runtime.Stack(a[:], false)]
			runtime.SetFinalizer(&Q, func(Q *Queue) {
				if Q != nil && Q.dpiQueue != nil {
					fmt.Printf("ERROR: queue %p of NewQueue is not Closed!\n%s\n", Q, stack)
					Q.Close()
				}
			})
		}
	}

	enqOpts := DefaultEnqOptions
	deqOpts := DefaultDeqOptions
	for _, o := range options {
		switch x := o.(type) {
		case DeqOptions:
			deqOpts = x
		case EnqOptions:
			enqOpts = x
		}
	}
	if err = Q.SetEnqOptions(enqOpts); err != nil {
		cx.Close()
		Q.Close()
		return nil, err
	}
	if err = Q.SetDeqOptions(deqOpts); err != nil {
		cx.Close()
		Q.Close()
		return nil, err
	}
	return &Q, nil
}

// Close the queue.
func (Q *Queue) Close() error {
	if Q == nil {
		return nil
	}
	c, q := Q.conn, Q.dpiQueue
	Q.conn, Q.dpiQueue = nil, nil
	if q == nil {
		return nil
	}
	if err := c.checkExec(func()  /*line :155:31*/_Ctype_int /*line :155:36*/ { return func() _Ctype_int{ _cgo0 := /*line :155:65*/q; _cgoCheckPointer(_cgo0, nil); return /*line :155:67*/_Cfunc_dpiQueue_release(_cgo0); }() }); err != nil {
		return fmt.Errorf("release: %w", err)
	}
	if Q.PayloadObjectType != nil && Q.PayloadObjectType.dpiObjectType != nil {
		Q.PayloadObjectType.Close()
		Q.PayloadObjectType = nil
	}
	if c != nil && Q.connIsOwned {
		c.Close()
	}
	return nil
}

// Purge the expired messages from the queue.
func (Q *Queue) PurgeExpired(ctx context.Context) error {
	return Q.execQ(ctx, `BEGIN 
  FOR row IN (
    SELECT sys_context('USERENV', 'CURRENT_SCHEMA')||'.'||queue_table AS queue_table 
	  FROM user_queues
	  WHERE name = :1
  ) LOOP
    dbms_aqadm.purge_queue_table(row.queue_table, 'qtview.msg_state = ''EXPIRED''', NULL);
  END LOOP;
END;`,
	)
}

// Name of the queue.
func (Q *Queue) Name() string { return Q.name }

// EnqOptions returns the queue's enqueue options in effect.
func (Q *Queue) EnqOptions() (EnqOptions, error) {
	var E EnqOptions
	var opts * /*line :188:12*/_Ctype_dpiEnqOptions /*line :188:27*/
	if err := Q.conn.checkExec(func()  /*line :189:36*/_Ctype_int /*line :189:41*/ { return func() _Ctype_int{ _cgo0 := /*line :189:76*/Q.dpiQueue; _cgoBase1 := /*line :189:88*/&opts; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :189:94*/_Cfunc_dpiQueue_getEnqOptions(_cgo0, _cgo1); }() }); err != nil {
		return E, fmt.Errorf("getEnqOptions: %w", err)
	}
	err := E.fromOra(Q.conn.drv, opts)
	return E, err
}

// DeqOptions returns the queue's dequeue options in effect.
func (Q *Queue) DeqOptions() (DeqOptions, error) {
	var D DeqOptions
	var opts * /*line :199:12*/_Ctype_dpiDeqOptions /*line :199:27*/
	if err := Q.conn.checkExec(func()  /*line :200:36*/_Ctype_int /*line :200:41*/ { return func() _Ctype_int{ _cgo0 := /*line :200:76*/Q.dpiQueue; _cgoBase1 := /*line :200:88*/&opts; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :200:94*/_Cfunc_dpiQueue_getDeqOptions(_cgo0, _cgo1); }() }); err != nil {
		return D, fmt.Errorf("getDeqOptions: %w", err)
	}
	err := D.fromOra(Q.conn.drv, opts)
	return D, err
}

// Dequeues messages into the given slice.
// Returns the number of messages filled in the given slice.
func (Q *Queue) Dequeue(messages []Message) (int, error) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Q.mu.Lock()
	defer Q.mu.Unlock()
	var props []* /*line :215:15*/_Ctype_dpiMsgProps /*line :215:28*/
	if cap(Q.props) >= len(messages) {
		props = Q.props[:len(messages)]
	} else {
		props = make([]* /*line :219:19*/_Ctype_dpiMsgProps /*line :219:32*/, len(messages))
	}
	Q.props = props

	var num  /*line :223:10*/_Ctype_uint /*line :223:16*/
	deqOne := len(props) == 1
	dequeue := func()  /*line :225:20*/_Ctype_int /*line :225:25*/ {
		num =  /*line :226:9*/_Ctype_uint /*line :226:15*/(len(props))
		if deqOne {
			return func() _Ctype_int{ _cgo0 := /*line :228:29*/Q.dpiQueue; _cgoIndex1 := &/*line :228:42*/props; _cgo1 := /*line :228:41*/&(*_cgoIndex1)[0]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :228:51*/_Cfunc_dpiQueue_deqOne(_cgo0, _cgo1); }()
		}
		return func() _Ctype_int{ _cgo0 := /*line :230:29*/Q.dpiQueue; var _cgo1 *_Ctype_uint32_t = /*line :230:41*/&num; _cgoIndex2 := &/*line :230:48*/props; _cgo2 := /*line :230:47*/&(*_cgoIndex2)[0]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :230:57*/_Cfunc_dpiQueue_deqMany(_cgo0, _cgo1, _cgo2); }()
	}
	if dequeue() == ( /*line :232:18*/_Ciconst_DPI_FAILURE /*line :232:30*/) {
		err := Q.conn.getError()
		var ec interface{ Code() int }
		if errors.As(err, &ec) {
			switch ec.Code() {
			case 3156:
				err = nil
			case 24010: // 0RA-24010: Queue does not exist
				Q.Close()
				//case 25263: // ORA-25263: no message in queue with message ID
				//return 0, nil
			case 25226: // ORA-25226: dequeue failed, queue <owner>.<queue_name> is not enabled for dequeue
				if startErr := Q.start(); startErr != nil {
					return 0, multiErrorf("%w: %w", "%+v: %w", startErr, err)
				} else {
					// try again
					if dequeue() == ( /*line :248:22*/_Ciconst_DPI_FAILURE /*line :248:34*/) {
						err = Q.conn.getError()
					} else {
						err = nil
					}
				}
			}
		}
		if err != nil {
			return 0, fmt.Errorf("dequeue: %w", err)
		}
	}

	var firstErr error
	for i, p := range props[:int(num)] {
		if err := messages[i].fromOra(Q.conn, p, Q.PayloadObjectType); err != nil {
			if firstErr == nil {
				firstErr = err
			}
		}
		func() _Ctype_int{ _cgo0 := /*line :268:25*/p; _cgoCheckPointer(_cgo0, nil); return /*line :268:27*/_Cfunc_dpiMsgProps_release(_cgo0); }()
		if deqOne && messages[i].IsZero() {
			return 0, nil
		}
	}
	return int(num), firstErr
}

func (Q *Queue) execQ(ctx context.Context, qry string) error {
	stmt, err := Q.conn.PrepareContext(ctx, qry)
	if err != nil {
		return fmt.Errorf("%s: %w", qry, err)
	}
	defer stmt.Close()
	if _, err = stmt.(driver.StmtExecContext).
		ExecContext(ctx, []driver.NamedValue{
			{Ordinal: 1, Value: Q.name},
		}); err != nil {
		return fmt.Errorf("%s [%q]: %w", qry, Q.name, err)
	}
	return nil
}
func (Q *Queue) start() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return Q.execQ(ctx, `BEGIN DBMS_AQADM.start_queue(queue_name=>:1); END;`)
}

// Enqueue all the messages given.
//
// WARNING: calling this function in parallel on different connections acquired from the same pool may fail due to Oracle bug 29928074.
// Ensure that this function is not run in parallel, use standalone connections or connections from different pools, or make multiple calls to Queue.enqOne() instead.
// The function Queue.Dequeue() call is not affected.
func (Q *Queue) Enqueue(messages []Message) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Q.mu.Lock()
	defer Q.mu.Unlock()
	var props []* /*line :307:15*/_Ctype_dpiMsgProps /*line :307:28*/
	if cap(Q.props) >= len(messages) {
		props = Q.props[:len(messages)]
	} else {
		props = make([]* /*line :311:19*/_Ctype_dpiMsgProps /*line :311:32*/, len(messages))
	}
	Q.props = props
	defer func() {
		for _, p := range props {
			if p != nil {
				func() _Ctype_int{ _cgo0 := /*line :317:27*/p; _cgoCheckPointer(_cgo0, nil); return /*line :317:29*/_Cfunc_dpiMsgProps_release(_cgo0); }()
			}
		}
	}()
	for i, m := range messages {
		if func() _Ctype_int{ _cgo0 := /*line :322:28*/Q.conn.dpiConn; _cgoIndex1 := &/*line :322:45*/props; _cgo1 := /*line :322:44*/&(*_cgoIndex1)[i]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :322:54*/_Cfunc_dpiConn_newMsgProps(_cgo0, _cgo1); }() == ( /*line :322:58*/_Ciconst_DPI_FAILURE /*line :322:70*/) {
			return fmt.Errorf("newMsgProps: %w", Q.conn.getError())
		}
		if err := m.toOra(Q.conn.drv, props[i]); err != nil {
			return err
		}
	}

	enqueue := func()  /*line :330:20*/_Ctype_int /*line :330:25*/ {
		if len(messages) == 1 {
			return func() _Ctype_int{ _cgo0 := /*line :332:29*/Q.dpiQueue; _cgo1 := /*line :332:41*/props[0]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :332:50*/_Cfunc_dpiQueue_enqOne(_cgo0, _cgo1); }()
		}
		return func() _Ctype_int{ _cgo0 := /*line :334:29*/Q.dpiQueue; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :334:47*/(len(props)); _cgoIndex2 := &/*line :334:62*/props; _cgo2 := /*line :334:61*/&(*_cgoIndex2)[0]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :334:71*/_Cfunc_dpiQueue_enqMany(_cgo0, _cgo1, _cgo2); }()
	}
	if enqueue() == ( /*line :336:18*/_Ciconst_DPI_FAILURE /*line :336:30*/) {
		err := Q.conn.getError()
		var ec interface{ Code() int }
		if errors.As(err, &ec) {
			switch ec.Code() {
			case 24010: // 0RA-24010: Queue does not exist
				Q.Close()
			case 25207: // ORA-25207: enque failed, queue string.string is disabled from enqueuing
				if startErr := Q.start(); startErr != nil {
					err = multiErrorf("%w: %w", "%+v: %w", startErr, err)
				} else {
					// try again
					if enqueue() == ( /*line :348:22*/_Ciconst_DPI_FAILURE /*line :348:34*/) {
						err = Q.conn.getError()
					} else {
						err = nil
					}
				}
			}
		}
		if err != nil {
			return fmt.Errorf("enqueue %#v: %w", messages, err)
		}
	}

	// Read back the MsgIDs
	for i, p := range props {
		var value * /*line :363:14*/_Ctype_char /*line :363:20*/
		var length  /*line :364:14*/_Ctype_uint /*line :364:20*/
		if func() _Ctype_int{ _cgo0 := /*line :365:29*/p; _cgoBase1 := /*line :365:32*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :365:40*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :365:48*/_Cfunc_dpiMsgProps_getMsgId(_cgo0, _cgo1, _cgo2); }() == ( /*line :365:52*/_Ciconst_DPI_FAILURE /*line :365:64*/) {
			return fmt.Errorf("getMsgID: %w", Q.conn.getError())
		}
		messages[i].writeMsgID(value, length)
	}

	return nil
}

// Message is a message - either received or being sent.
type Message struct {
	Enqueued                time.Time
	Object                  *Object
	Correlation, ExceptionQ string
	Raw                     []byte
	Delay, Expiration       time.Duration
	DeliveryMode            DeliveryMode
	State                   MessageState
	Priority, NumAttempts   int32
	MsgID, OriginalMsgID    [16]byte
}

func (M Message) IsZero() bool {
	return M.Correlation == "" && M.ExceptionQ == "" && M.Enqueued.IsZero() &&
		M.MsgID == zeroMsgID && M.OriginalMsgID == zeroMsgID && len(M.Raw) == 0 &&
		M.Delay == 0 && M.Expiration == 0 && M.Priority == 0 && M.NumAttempts == 0 &&
		M.Object == nil && M.State == 0
}

// Deadline return the message's intended deadline: enqueue time + delay + expiration.
func (M Message) Deadline() time.Time {
	if M.Enqueued.IsZero() {
		return M.Enqueued
	}
	return M.Enqueued.Add(M.Delay + M.Expiration)
}
func (M *Message) toOra(d *drv, props * /*line :401:40*/_Ctype_dpiMsgProps /*line :401:53*/) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :406:16*/_Ctype_int /*line :406:21*/, name string) {
		if ok != ( /*line :407:12*/_Ciconst_DPI_FAILURE /*line :407:24*/) {
			return
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", name, d.getError())
		}
	}
	if M.Correlation != "" {
		value := ( /*line :415:12*/_Cfunc_CString /*line :415:20*/)(M.Correlation)
		OK(func() _Ctype_int{ _cgo0 := /*line :416:35*/props; var _cgo1 *_Ctype_char = /*line :416:42*/value; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :416:55*/(len(M.Correlation)); _cgoCheckPointer(_cgo0, nil); return /*line :416:76*/_Cfunc_dpiMsgProps_setCorrelation(_cgo0, _cgo1, _cgo2); }(), "setCorrelation")
	}

	OK(func() _Ctype_int{ _cgo0 := /*line :419:28*/props; var _cgo1 _Ctype_int32_t = _Ctype_int /*line :419:40*/(M.Delay / time.Second); _cgoCheckPointer(_cgo0, nil); return /*line :419:62*/_Cfunc_dpiMsgProps_setDelay(_cgo0, _cgo1); }(), "setDelay")

	if M.ExceptionQ != "" {
		value := ( /*line :422:12*/_Cfunc_CString /*line :422:20*/)(M.ExceptionQ)
		OK(func() _Ctype_int{ _cgo0 := /*line :423:34*/props; var _cgo1 *_Ctype_char = /*line :423:41*/value; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :423:54*/(len(M.ExceptionQ)); _cgoCheckPointer(_cgo0, nil); return /*line :423:74*/_Cfunc_dpiMsgProps_setExceptionQ(_cgo0, _cgo1, _cgo2); }(), "setExceptionQ")
	}

	OK(func() _Ctype_int{ _cgo0 := /*line :426:33*/props; var _cgo1 _Ctype_int32_t = _Ctype_int /*line :426:45*/(M.Expiration / time.Second); _cgoCheckPointer(_cgo0, nil); return /*line :426:72*/_Cfunc_dpiMsgProps_setExpiration(_cgo0, _cgo1); }(), "setExpiration")

	if M.OriginalMsgID != zeroMsgID {
		OK(func() _Ctype_int{ _cgo0 := /*line :429:37*/props; var _cgo1 *_Ctype_char = /*line :429:44*/(*_Ctype_char /*line :429:52*/)(unsafe.Pointer(&M.OriginalMsgID[0])); var _cgo2 _Ctype_uint32_t = /*line :429:92*/MsgIDLength; _cgoCheckPointer(_cgo0, nil); return /*line :429:104*/_Cfunc_dpiMsgProps_setOriginalMsgId(_cgo0, _cgo1, _cgo2); }(), "setMsgOriginalId")
	}

	OK(func() _Ctype_int{ _cgo0 := /*line :432:31*/props; var _cgo1 _Ctype_int32_t = _Ctype_int /*line :432:43*/(M.Priority); _cgoCheckPointer(_cgo0, nil); return /*line :432:56*/_Cfunc_dpiMsgProps_setPriority(_cgo0, _cgo1); }(), "setPriority")

	if M.Object == nil {
		OK(func() _Ctype_int{ _cgo0 := /*line :435:36*/props; var _cgo1 *_Ctype_char = /*line :435:43*/(*_Ctype_char /*line :435:51*/)(unsafe.Pointer(&M.Raw[0])); var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :435:87*/(len(M.Raw)); _cgoCheckPointer(_cgo0, nil); return /*line :435:100*/_Cfunc_dpiMsgProps_setPayloadBytes(_cgo0, _cgo1, _cgo2); }(), "setPayloadBytes")
	} else {
		OK(func() _Ctype_int{ _cgo0 := /*line :437:37*/props; _cgo1 := /*line :437:44*/M.Object.dpiObject; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :437:63*/_Cfunc_dpiMsgProps_setPayloadObject(_cgo0, _cgo1); }(), "setPayloadObject")
	}

	return firstErr
}

func (M *Message) fromOra(c *conn, props * /*line :443:43*/_Ctype_dpiMsgProps /*line :443:56*/, objType *ObjectType) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :448:16*/_Ctype_int /*line :448:21*/, name string) bool {
		if ok != ( /*line :449:12*/_Ciconst_DPI_FAILURE /*line :449:24*/) {
			return true
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", name, c.getError())
		}
		return false
	}
	M.NumAttempts = 0
	var cint  /*line :458:11*/_Ctype_int /*line :458:16*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :459:37*/props; var _cgo1 *_Ctype_int32_t = /*line :459:44*/&cint; _cgoCheckPointer(_cgo0, nil); return /*line :459:50*/_Cfunc_dpiMsgProps_getNumAttempts(_cgo0, _cgo1); }(), "getNumAttempts") {
		M.NumAttempts = int32(cint)
	}
	var value * /*line :462:13*/_Ctype_char /*line :462:19*/
	var length  /*line :463:13*/_Ctype_uint /*line :463:19*/
	M.Correlation = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :465:37*/props; _cgoBase1 := /*line :465:44*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :465:52*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :465:60*/_Cfunc_dpiMsgProps_getCorrelation(_cgo0, _cgo1, _cgo2); }(), "getCorrelation") && value != nil && length != 0 {
		M.Correlation = ( /*line :466:19*/_Cfunc_GoStringN /*line :466:29*/)(value,  /*line :466:38*/_Ctype_int /*line :466:43*/(length))
	}

	M.Delay = 0
	if OK(func() _Ctype_int{ _cgo0 := /*line :470:31*/props; var _cgo1 *_Ctype_int32_t = /*line :470:38*/&cint; _cgoCheckPointer(_cgo0, nil); return /*line :470:44*/_Cfunc_dpiMsgProps_getDelay(_cgo0, _cgo1); }(), "getDelay") && cint > 0 {
		M.Delay = time.Duration(cint) * time.Second
	}

	M.DeliveryMode = DeliverPersistent
	var mode  /*line :475:11*/_Ctype_dpiMessageDeliveryMode /*line :475:35*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :476:38*/props; var _cgo1 *_Ctype_dpiMessageDeliveryMode = /*line :476:45*/&mode; _cgoCheckPointer(_cgo0, nil); return /*line :476:51*/_Cfunc_dpiMsgProps_getDeliveryMode(_cgo0, _cgo1); }(), "getDeliveryMode") {
		M.DeliveryMode = DeliveryMode(mode)
	}

	M.ExceptionQ = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :481:36*/props; _cgoBase1 := /*line :481:43*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :481:51*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :481:59*/_Cfunc_dpiMsgProps_getExceptionQ(_cgo0, _cgo1, _cgo2); }(), "getExceptionQ") && value != nil && length != 0 {
		M.ExceptionQ = ( /*line :482:18*/_Cfunc_GoStringN /*line :482:28*/)(value,  /*line :482:37*/_Ctype_int /*line :482:42*/(length))
	}

	var ts  /*line :485:9*/_Ctype_dpiTimestamp /*line :485:23*/
	M.Enqueued = time.Time{}
	if OK(func() _Ctype_int{ _cgo0 := /*line :487:33*/props; var _cgo1 *_Ctype_struct___20 = /*line :487:40*/&ts; _cgoCheckPointer(_cgo0, nil); return /*line :487:44*/_Cfunc_dpiMsgProps_getEnqTime(_cgo0, _cgo1); }(), "getEnqTime") {
		M.Enqueued = time.Date(
			int(ts.year), time.Month(ts.month), int(ts.day),
			int(ts.hour), int(ts.minute), int(ts.second), int(ts.fsecond),
			timeZoneFor(ts.tzHourOffset, ts.tzMinuteOffset, c.params.Timezone),
		)
	}

	M.Expiration = 0
	if OK(func() _Ctype_int{ _cgo0 := /*line :496:36*/props; var _cgo1 *_Ctype_int32_t = /*line :496:43*/&cint; _cgoCheckPointer(_cgo0, nil); return /*line :496:49*/_Cfunc_dpiMsgProps_getExpiration(_cgo0, _cgo1); }(), "getExpiration") && cint > 0 {
		M.Expiration = time.Duration(cint) * time.Second
	}

	M.MsgID = zeroMsgID
	if OK(func() _Ctype_int{ _cgo0 := /*line :501:31*/props; _cgoBase1 := /*line :501:38*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :501:46*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :501:54*/_Cfunc_dpiMsgProps_getMsgId(_cgo0, _cgo1, _cgo2); }(), "getMsgId") {
		M.writeMsgID(value, length)
	}

	M.OriginalMsgID = zeroMsgID
	if OK(func() _Ctype_int{ _cgo0 := /*line :506:39*/props; _cgoBase1 := /*line :506:46*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :506:54*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :506:62*/_Cfunc_dpiMsgProps_getOriginalMsgId(_cgo0, _cgo1, _cgo2); }(), "getMsgOriginalId") {
		n :=  /*line :507:8*/_Ctype_int /*line :507:13*/(length)
		if n > MsgIDLength {
			n = MsgIDLength
		}
		copy(M.OriginalMsgID[:], func() []byte{ _cgo0 := /*line :511:38*/unsafe.Pointer(value); var _cgo1 _Ctype_int = /*line :511:61*/n; _cgoCheckPointer(_cgo0, nil); return /*line :511:63*/_Cfunc_GoBytes(_cgo0, _cgo1); }())
	}

	M.Priority = 0
	if OK(func() _Ctype_int{ _cgo0 := /*line :515:34*/props; var _cgo1 *_Ctype_int32_t = /*line :515:41*/&cint; _cgoCheckPointer(_cgo0, nil); return /*line :515:47*/_Cfunc_dpiMsgProps_getPriority(_cgo0, _cgo1); }(), "getPriority") {
		M.Priority = int32(cint)
	}

	M.State = 0
	var state  /*line :520:12*/_Ctype_dpiMessageState /*line :520:29*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :521:31*/props; var _cgo1 *_Ctype_dpiMessageState = /*line :521:38*/&state; _cgoCheckPointer(_cgo0, nil); return /*line :521:45*/_Cfunc_dpiMsgProps_getState(_cgo0, _cgo1); }(), "getState") {
		M.State = MessageState(state)
	}

	M.Raw = nil
	M.Object = nil
	var obj * /*line :527:11*/_Ctype_dpiObject /*line :527:22*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :528:33*/props; _cgoBase1 := /*line :528:40*/&obj; _cgo1 := _cgoBase1; _cgoBase2 := /*line :528:46*/&value; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_uint32_t = /*line :528:54*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :528:62*/_Cfunc_dpiMsgProps_getPayload(_cgo0, _cgo1, _cgo2, _cgo3); }(), "getPayload") {
		if obj == nil {
			M.Raw = func() []byte{ _cgo0 := /*line :530:22*/unsafe.Pointer(value); var _cgo1 _Ctype_int = _Ctype_int /*line :530:50*/(length); _cgoCheckPointer(_cgo0, nil); return /*line :530:59*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
		} else {
			if func() _Ctype_int{ _cgo0 := /*line :532:26*/obj; _cgoCheckPointer(_cgo0, nil); return /*line :532:30*/_Cfunc_dpiObject_addRef(_cgo0); }() == ( /*line :532:34*/_Ciconst_DPI_FAILURE /*line :532:46*/) {
				return objType.drv.getError()
			}
			M.Object = &Object{dpiObject: obj, ObjectType: objType}
		}
	}
	return nil
}

func (M *Message) writeMsgID(value * /*line :541:37*/_Ctype_char /*line :541:43*/, length  /*line :541:52*/_Ctype_uint /*line :541:58*/) {
	n :=  /*line :542:7*/_Ctype_int /*line :542:12*/(length)
	if n > MsgIDLength {
		n = MsgIDLength
	}
	copy(M.MsgID[:], func() []byte{ _cgo0 := /*line :546:29*/unsafe.Pointer(value); var _cgo1 _Ctype_int = /*line :546:52*/n; _cgoCheckPointer(_cgo0, nil); return /*line :546:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }())
	for i := n; i < MsgIDLength; i++ {
		M.MsgID[i] = 0
	}
}

// EnqOptions are the options used to enqueue a message.
type EnqOptions struct {
	Transformation string
	Visibility     Visibility
	DeliveryMode   DeliveryMode
}

func (EnqOptions) qOption() {}

func (E *EnqOptions) fromOra(d *drv, opts * /*line :561:44*/_Ctype_dpiEnqOptions /*line :561:59*/) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :566:16*/_Ctype_int /*line :566:21*/, msg string) bool {
		if ok != ( /*line :567:12*/_Ciconst_DPI_FAILURE /*line :567:24*/) {
			return true
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", msg, d.getError())
		}
		return false
	}

	E.DeliveryMode = DeliverPersistent

	var value * /*line :578:13*/_Ctype_char /*line :578:19*/
	var length  /*line :579:13*/_Ctype_uint /*line :579:19*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :580:42*/opts; _cgoBase1 := /*line :580:48*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :580:56*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :580:64*/_Cfunc_dpiEnqOptions_getTransformation(_cgo0, _cgo1, _cgo2); }(), "getTransformation") && value != nil && length != 0 {
		E.Transformation = ( /*line :581:22*/_Cfunc_GoStringN /*line :581:32*/)(value,  /*line :581:41*/_Ctype_int /*line :581:46*/(length))
	}

	var vis  /*line :584:10*/_Ctype_dpiVisibility /*line :584:25*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :585:38*/opts; var _cgo1 *_Ctype_dpiVisibility = /*line :585:44*/&vis; _cgoCheckPointer(_cgo0, nil); return /*line :585:49*/_Cfunc_dpiEnqOptions_getVisibility(_cgo0, _cgo1); }(), "getVisibility") {
		E.Visibility = Visibility(vis)
	}

	return firstErr
}

func (E EnqOptions) toOra(d *drv, opts * /*line :592:41*/_Ctype_dpiEnqOptions /*line :592:56*/) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :597:16*/_Ctype_int /*line :597:21*/, msg string) bool {
		if ok != ( /*line :598:12*/_Ciconst_DPI_FAILURE /*line :598:24*/) {
			return true
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", msg, d.getError())
		}
		return false
	}

	OK(func() _Ctype_int{ _cgo0 := /*line :607:37*/opts; var _cgo1 _Ctype_dpiMessageDeliveryMode = _Ctype_dpiMessageDeliveryMode /*line :607:67*/(E.DeliveryMode); _cgoCheckPointer(_cgo0, nil); return /*line :607:84*/_Cfunc_dpiEnqOptions_setDeliveryMode(_cgo0, _cgo1); }(), "setDeliveryMode")
	cs := ( /*line :608:8*/_Cfunc_CString /*line :608:16*/)(E.Transformation)
	OK(func() _Ctype_int{ _cgo0 := /*line :609:39*/opts; var _cgo1 *_Ctype_char = /*line :609:45*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :609:55*/(len(E.Transformation)); _cgoCheckPointer(_cgo0, nil); return /*line :609:79*/_Cfunc_dpiEnqOptions_setTransformation(_cgo0, _cgo1, _cgo2); }(), "setTransformation")
	func() { _cgo0 := /*line :610:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :610:28*/_Cfunc_free(_cgo0); }()
	OK(func() _Ctype_int{ _cgo0 := /*line :611:35*/opts; var _cgo1 _Ctype_dpiVisibility = _Ctype_uint /*line :611:47*/(E.Visibility); _cgoCheckPointer(_cgo0, nil); return /*line :611:62*/_Cfunc_dpiEnqOptions_setVisibility(_cgo0, _cgo1); }(), "setVisibility")
	return firstErr
}

// SetEnqOptions sets all the enqueue options
func (Q *Queue) SetEnqOptions(E EnqOptions) error {
	var opts * /*line :617:12*/_Ctype_dpiEnqOptions /*line :617:27*/
	if err := Q.conn.checkExec(func()  /*line :618:36*/_Ctype_int /*line :618:41*/ { return func() _Ctype_int{ _cgo0 := /*line :618:76*/Q.dpiQueue; _cgoBase1 := /*line :618:88*/&opts; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :618:94*/_Cfunc_dpiQueue_getEnqOptions(_cgo0, _cgo1); }() }); err != nil {
		return fmt.Errorf("getEnqOptions: %w", err)
	}
	return E.toOra(Q.conn.drv, opts)
}

// DeqOptions are the options used to dequeue a message.
type DeqOptions struct {
	Condition, Consumer, Correlation string
	MsgID                            []byte
	Transformation                   string
	Mode                             DeqMode
	DeliveryMode                     DeliveryMode
	Navigation                       DeqNavigation
	Visibility                       Visibility
	Wait                             time.Duration
}

func (DeqOptions) qOption() {}

func (D *DeqOptions) fromOra(d *drv, opts * /*line :638:44*/_Ctype_dpiDeqOptions /*line :638:59*/) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :643:16*/_Ctype_int /*line :643:21*/, msg string) bool {
		if ok != ( /*line :644:12*/_Ciconst_DPI_FAILURE /*line :644:24*/) {
			return true
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", msg, d.getError())
		}
		return false
	}

	var value * /*line :653:13*/_Ctype_char /*line :653:19*/
	var length  /*line :654:13*/_Ctype_uint /*line :654:19*/
	D.Transformation = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :656:42*/opts; _cgoBase1 := /*line :656:48*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :656:56*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :656:64*/_Cfunc_dpiDeqOptions_getTransformation(_cgo0, _cgo1, _cgo2); }(), "getTransformation") && value != nil && length != 0 {
		D.Transformation = ( /*line :657:22*/_Cfunc_GoStringN /*line :657:32*/)(value,  /*line :657:41*/_Ctype_int /*line :657:46*/(length))
	}
	D.Condition = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :660:37*/opts; _cgoBase1 := /*line :660:43*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :660:51*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :660:59*/_Cfunc_dpiDeqOptions_getCondition(_cgo0, _cgo1, _cgo2); }(), "getCondifion") && value != nil && length != 0 {
		D.Condition = ( /*line :661:17*/_Cfunc_GoStringN /*line :661:27*/)(value,  /*line :661:36*/_Ctype_int /*line :661:41*/(length))
	}
	D.Consumer = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :664:40*/opts; _cgoBase1 := /*line :664:46*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :664:54*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :664:62*/_Cfunc_dpiDeqOptions_getConsumerName(_cgo0, _cgo1, _cgo2); }(), "getConsumer") && value != nil && length != 0 {
		D.Consumer = ( /*line :665:16*/_Cfunc_GoStringN /*line :665:26*/)(value,  /*line :665:35*/_Ctype_int /*line :665:40*/(length))
	}
	D.Correlation = ""
	if OK(func() _Ctype_int{ _cgo0 := /*line :668:39*/opts; _cgoBase1 := /*line :668:45*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :668:53*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :668:61*/_Cfunc_dpiDeqOptions_getCorrelation(_cgo0, _cgo1, _cgo2); }(), "getCorrelation") && value != nil && length != 0 {
		D.Correlation = ( /*line :669:19*/_Cfunc_GoStringN /*line :669:29*/)(value,  /*line :669:38*/_Ctype_int /*line :669:43*/(length))
	}
	D.DeliveryMode = DeliverPersistent
	var mode  /*line :672:11*/_Ctype_dpiDeqMode /*line :672:23*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :673:32*/opts; var _cgo1 *_Ctype_dpiDeqMode = /*line :673:38*/&mode; _cgoCheckPointer(_cgo0, nil); return /*line :673:44*/_Cfunc_dpiDeqOptions_getMode(_cgo0, _cgo1); }(), "getMode") {
		D.Mode = DeqMode(mode)
	}
	D.MsgID = nil
	if OK(func() _Ctype_int{ _cgo0 := /*line :677:33*/opts; _cgoBase1 := /*line :677:39*/&value; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :677:47*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :677:55*/_Cfunc_dpiDeqOptions_getMsgId(_cgo0, _cgo1, _cgo2); }(), "getMsgId") {
		if length != 0 {
			//D.MsgID = ((*[1 << 30]byte)(unsafe.Pointer(value)))[:int(length):int(length)]
			D.MsgID = ([]byte)(unsafe.Slice((*byte)(unsafe.Pointer(value)), length))
		}
	}
	var nav  /*line :683:10*/_Ctype_dpiDeqNavigation /*line :683:28*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :684:38*/opts; var _cgo1 *_Ctype_dpiDeqNavigation = /*line :684:44*/&nav; _cgoCheckPointer(_cgo0, nil); return /*line :684:49*/_Cfunc_dpiDeqOptions_getNavigation(_cgo0, _cgo1); }(), "getNavigation") {
		D.Navigation = DeqNavigation(nav)
	}
	var vis  /*line :687:10*/_Ctype_dpiVisibility /*line :687:25*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :688:38*/opts; var _cgo1 *_Ctype_dpiVisibility = /*line :688:44*/&vis; _cgoCheckPointer(_cgo0, nil); return /*line :688:49*/_Cfunc_dpiDeqOptions_getVisibility(_cgo0, _cgo1); }(), "getVisibility") {
		D.Visibility = Visibility(vis)
	}
	D.Wait = 0
	var u32  /*line :692:10*/_Ctype_uint /*line :692:16*/
	if OK(func() _Ctype_int{ _cgo0 := /*line :693:32*/opts; var _cgo1 *_Ctype_uint32_t = /*line :693:38*/&u32; _cgoCheckPointer(_cgo0, nil); return /*line :693:43*/_Cfunc_dpiDeqOptions_getWait(_cgo0, _cgo1); }(), "getWait") {
		D.Wait = time.Duration(u32) * time.Second
	}
	return firstErr
}

func (D DeqOptions) toOra(d *drv, opts * /*line :699:41*/_Ctype_dpiDeqOptions /*line :699:56*/) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var firstErr error
	OK := func(ok  /*line :704:16*/_Ctype_int /*line :704:21*/, msg string) bool {
		if ok != ( /*line :705:12*/_Ciconst_DPI_FAILURE /*line :705:24*/) {
			return true
		}
		if firstErr == nil {
			firstErr = fmt.Errorf("%s: %w", msg, d.getError())
		}
		return false
	}

	cs := ( /*line :714:8*/_Cfunc_CString /*line :714:16*/)(D.Transformation)
	OK(func() _Ctype_int{ _cgo0 := /*line :715:39*/opts; var _cgo1 *_Ctype_char = /*line :715:45*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :715:55*/(len(D.Transformation)); _cgoCheckPointer(_cgo0, nil); return /*line :715:79*/_Cfunc_dpiDeqOptions_setTransformation(_cgo0, _cgo1, _cgo2); }(), "setTransformation")
	func() { _cgo0 := /*line :716:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :716:28*/_Cfunc_free(_cgo0); }()

	cs = ( /*line :718:7*/_Cfunc_CString /*line :718:15*/)(D.Condition)
	OK(func() _Ctype_int{ _cgo0 := /*line :719:34*/opts; var _cgo1 *_Ctype_char = /*line :719:40*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :719:50*/(len(D.Condition)); _cgoCheckPointer(_cgo0, nil); return /*line :719:69*/_Cfunc_dpiDeqOptions_setCondition(_cgo0, _cgo1, _cgo2); }(), "setCondifion")
	func() { _cgo0 := /*line :720:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :720:28*/_Cfunc_free(_cgo0); }()

	cs = ( /*line :722:7*/_Cfunc_CString /*line :722:15*/)(D.Consumer)
	OK(func() _Ctype_int{ _cgo0 := /*line :723:37*/opts; var _cgo1 *_Ctype_char = /*line :723:43*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :723:53*/(len(D.Consumer)); _cgoCheckPointer(_cgo0, nil); return /*line :723:71*/_Cfunc_dpiDeqOptions_setConsumerName(_cgo0, _cgo1, _cgo2); }(), "setConsumer")
	func() { _cgo0 := /*line :724:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :724:28*/_Cfunc_free(_cgo0); }()

	cs = ( /*line :726:7*/_Cfunc_CString /*line :726:15*/)(D.Correlation)
	OK(func() _Ctype_int{ _cgo0 := /*line :727:36*/opts; var _cgo1 *_Ctype_char = /*line :727:42*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :727:52*/(len(D.Correlation)); _cgoCheckPointer(_cgo0, nil); return /*line :727:73*/_Cfunc_dpiDeqOptions_setCorrelation(_cgo0, _cgo1, _cgo2); }(), "setCorrelation")
	func() { _cgo0 := /*line :728:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :728:28*/_Cfunc_free(_cgo0); }()

	OK(func() _Ctype_int{ _cgo0 := /*line :730:37*/opts; var _cgo1 _Ctype_dpiMessageDeliveryMode = _Ctype_dpiMessageDeliveryMode /*line :730:67*/(D.DeliveryMode); _cgoCheckPointer(_cgo0, nil); return /*line :730:84*/_Cfunc_dpiDeqOptions_setDeliveryMode(_cgo0, _cgo1); }(), "setDeliveryMode")
	OK(func() _Ctype_int{ _cgo0 := /*line :731:29*/opts; var _cgo1 _Ctype_dpiDeqMode = _Ctype_dpiDeqMode /*line :731:47*/(D.Mode); _cgoCheckPointer(_cgo0, nil); return /*line :731:56*/_Cfunc_dpiDeqOptions_setMode(_cgo0, _cgo1); }(), "setMode")

	if D.MsgID == nil {
		var a [1]byte
		OK(func() _Ctype_int{ _cgo0 := /*line :735:31*/opts; var _cgo1 *_Ctype_char = /*line :735:37*/(*_Ctype_char /*line :735:45*/)(unsafe.Pointer(&a[0])); var _cgo2 _Ctype_uint32_t = /*line :735:71*/0; _cgoCheckPointer(_cgo0, nil); return /*line :735:73*/_Cfunc_dpiDeqOptions_setMsgId(_cgo0, _cgo1, _cgo2); }(), "setMsgId")
	} else {
		OK(func() _Ctype_int{ _cgo0 := /*line :737:31*/opts; var _cgo1 *_Ctype_char = /*line :737:37*/(*_Ctype_char /*line :737:45*/)(unsafe.Pointer(&D.MsgID[0])); var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :737:83*/(len(D.MsgID)); _cgoCheckPointer(_cgo0, nil); return /*line :737:98*/_Cfunc_dpiDeqOptions_setMsgId(_cgo0, _cgo1, _cgo2); }(), "setMsgId")
	}

	OK(func() _Ctype_int{ _cgo0 := /*line :740:35*/opts; var _cgo1 _Ctype_dpiDeqNavigation = _Ctype_dpiDeqNavigation /*line :740:59*/(D.Navigation); _cgoCheckPointer(_cgo0, nil); return /*line :740:74*/_Cfunc_dpiDeqOptions_setNavigation(_cgo0, _cgo1); }(), "setNavigation")

	OK(func() _Ctype_int{ _cgo0 := /*line :742:35*/opts; var _cgo1 _Ctype_dpiVisibility = _Ctype_dpiVisibility /*line :742:56*/(D.Visibility); _cgoCheckPointer(_cgo0, nil); return /*line :742:71*/_Cfunc_dpiDeqOptions_setVisibility(_cgo0, _cgo1); }(), "setVisibility")

	OK(func() _Ctype_int{ _cgo0 := /*line :744:29*/opts; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :744:41*/(D.Wait / time.Second); _cgoCheckPointer(_cgo0, nil); return /*line :744:62*/_Cfunc_dpiDeqOptions_setWait(_cgo0, _cgo1); }(), "setWait")

	return firstErr
}

// SetDeqOptions sets all the dequeue options
func (Q *Queue) SetDeqOptions(D DeqOptions) error {
	var opts * /*line :751:12*/_Ctype_dpiDeqOptions /*line :751:27*/
	if err := Q.conn.checkExec(func()  /*line :752:36*/_Ctype_int /*line :752:41*/ { return func() _Ctype_int{ _cgo0 := /*line :752:76*/Q.dpiQueue; _cgoBase1 := /*line :752:88*/&opts; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :752:94*/_Cfunc_dpiQueue_getDeqOptions(_cgo0, _cgo1); }() }); err != nil {
		return fmt.Errorf("getDeqOptions: %w", err)
	}
	return D.toOra(Q.conn.drv, opts)
}

// SetDeqCorrelation is a convenience function setting the Correlation DeqOption
func (Q *Queue) SetDeqCorrelation(correlation string) error {
	var opts * /*line :760:12*/_Ctype_dpiDeqOptions /*line :760:27*/
	if err := Q.conn.checkExec(func()  /*line :761:36*/_Ctype_int /*line :761:41*/ { return func() _Ctype_int{ _cgo0 := /*line :761:76*/Q.dpiQueue; _cgoBase1 := /*line :761:88*/&opts; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :761:94*/_Cfunc_dpiQueue_getDeqOptions(_cgo0, _cgo1); }() }); err != nil {
		return fmt.Errorf("getDeqOptions: %w", err)
	}
	cs := ( /*line :764:8*/_Cfunc_CString /*line :764:16*/)(correlation)
	err := Q.conn.checkExec(func()  /*line :765:33*/_Ctype_int /*line :765:38*/ { return func() _Ctype_int{ _cgo0 := /*line :765:79*/opts; var _cgo1 *_Ctype_char = /*line :765:85*/cs; var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :765:95*/(len(correlation)); _cgoCheckPointer(_cgo0, nil); return /*line :765:114*/_Cfunc_dpiDeqOptions_setCorrelation(_cgo0, _cgo1, _cgo2); }() })
	func() { _cgo0 := /*line :766:9*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :766:28*/_Cfunc_free(_cgo0); }()
	if err != nil {
		return fmt.Errorf("setCorrelation: %w", err)
	}
	return nil
}

// MessageState constants representing message's state.
type MessageState uint32

const (
	// MsgStateReady says that "The message is ready to be processed".
	MsgStateReady = MessageState(( /*line :778:31*/_Ciconst_DPI_MSG_STATE_READY /*line :778:51*/))
	// MsgStateWaiting says that "The message is waiting for the delay time to expire".
	MsgStateWaiting = MessageState(( /*line :780:33*/_Ciconst_DPI_MSG_STATE_WAITING /*line :780:55*/))
	// MsgStateProcessed says that "The message has already been processed and is retained".
	MsgStateProcessed = MessageState(( /*line :782:35*/_Ciconst_DPI_MSG_STATE_PROCESSED /*line :782:59*/))
	// MsgStateExpired says that "The message has been moved to the exception queue".
	MsgStateExpired = MessageState(( /*line :784:33*/_Ciconst_DPI_MSG_STATE_EXPIRED /*line :784:55*/))
)

// DeliveryMode constants for delivery modes.
type DeliveryMode uint32

const (
	// DeliverPersistent is to Dequeue only persistent messages from the queue. This is the default mode.
	DeliverPersistent = DeliveryMode(( /*line :792:35*/_Ciconst_DPI_MODE_MSG_PERSISTENT /*line :792:59*/))
	// DeliverBuffered is to Dequeue only buffered messages from the queue.
	DeliverBuffered = DeliveryMode(( /*line :794:33*/_Ciconst_DPI_MODE_MSG_BUFFERED /*line :794:55*/))
	// DeliverPersistentOrBuffered is to Dequeue both persistent and buffered messages from the queue.
	DeliverPersistentOrBuffered = DeliveryMode(( /*line :796:45*/_Ciconst_DPI_MODE_MSG_PERSISTENT_OR_BUFFERED /*line :796:81*/))
)

// Visibility constants represents visibility.
type Visibility uint32

const (
	// VisibleImmediate means that "The message is not part of the current transaction but constitutes a transaction of its own".
	VisibleImmediate = Visibility(( /*line :804:32*/_Ciconst_DPI_VISIBILITY_IMMEDIATE /*line :804:57*/))
	// VisibleOnCommit means that "The message is part of the current transaction. This is the default value".
	VisibleOnCommit = Visibility(( /*line :806:31*/_Ciconst_DPI_VISIBILITY_ON_COMMIT /*line :806:56*/))
)

// DeqMode constants for dequeue modes.
type DeqMode uint32

const (
	// DeqRemove reads the message and updates or deletes it. This is the default mode. Note that the message may be retained in the queue table based on retention properties.
	DeqRemove = DeqMode(( /*line :814:22*/_Ciconst_DPI_MODE_DEQ_REMOVE /*line :814:42*/))
	// DeqBrows reads the message without acquiring a lock on the message (equivalent to a SELECT statement).
	DeqBrowse = DeqMode(( /*line :816:22*/_Ciconst_DPI_MODE_DEQ_BROWSE /*line :816:42*/))
	// DeqLocked reads the message and obtain a write lock on the message (equivalent to a SELECT FOR UPDATE statement).
	DeqLocked = DeqMode(( /*line :818:22*/_Ciconst_DPI_MODE_DEQ_LOCKED /*line :818:42*/))
	// DeqPeek confirms receipt of the message but does not deliver the actual message content.
	DeqPeek = DeqMode(( /*line :820:20*/_Ciconst_DPI_MODE_DEQ_REMOVE_NO_DATA /*line :820:48*/))
)

// DeqNavigation constants for navigation.
type DeqNavigation uint32

const (
	// NavFirst retrieves the first available message that matches the search criteria. This resets the position to the beginning of the queue.
	NavFirst = DeqNavigation(( /*line :828:27*/_Ciconst_DPI_DEQ_NAV_FIRST_MSG /*line :828:49*/))
	// NavNext skips the remainder of the current transaction group (if any) and retrieves the first message of the next transaction group. This option can only be used if message grouping is enabled for the queue.
	NavNextTran = DeqNavigation(( /*line :830:30*/_Ciconst_DPI_DEQ_NAV_NEXT_TRANSACTION /*line :830:59*/))
	// NavNext  	Retrieves the next available message that matches the search criteria. This is the default method.
	NavNext = DeqNavigation(( /*line :832:26*/_Ciconst_DPI_DEQ_NAV_NEXT_MSG /*line :832:47*/))
)
