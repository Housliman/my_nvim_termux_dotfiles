// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/obj.go:1:1
// Copyright 2017, 2022 The Godror Authors
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package godror

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"bufio"
	"bytes"
	"context"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"sync"
	"unsafe"

	"github.com/godror/godror/slog"
)

const (
	warnMissingObjectClose   = true
	closeObjectWithFinalizer = false
)

var _ = fmt.Printf

// Object represents a dpiObject.
type Object struct {
	dpiObject * /*line :41:13*/_Ctype_dpiObject /*line :41:24*/
	*ObjectType
}

// ErrNoSuchKey is the error for missing key in lookup.
var ErrNoSuchKey = errors.New("no such key")

// GetAttribute gets the i-th attribute into data.
func (O *Object) GetAttribute(data *Data, name string) error {
	if O == nil {
		panic("nil Object")
	}
	attr, ok := O.Attributes[name]
	if !ok {
		return fmt.Errorf("get %s[%s]: %w (have: %q)", O.Name, name, ErrNoSuchKey, O.AttributeNames())
	}

	data.reset()
	data.NativeTypeNum = attr.NativeTypeNum
	data.ObjectType = attr.ObjectType
	data.implicitObj = true
	if O.dpiObject == nil {
		data.SetNull()
		return nil
	}
	// the maximum length of that buffer must be supplied
	// in the value.asBytes.length attribute before calling this function.
	if attr.NativeTypeNum == ( /*line :68:27*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :68:49*/) && attr.OracleTypeNum == ( /*line :68:76*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :68:99*/) {
		var a [39]byte
		( /*line :70:3*/_Cfunc_dpiData_setBytes /*line :70:20*/)(&data.dpiData, (* /*line :70:39*/_Ctype_char /*line :70:45*/)(unsafe.Pointer(&a[0])),  /*line :70:71*/_Ctype_uint32_t /*line :70:81*/(len(a)))
	}

	//fmt.Printf("getAttributeValue(%p, %p, %d, %+v)\n", O.dpiObject, attr.dpiObjectAttr, data.NativeTypeNum, data.dpiData)
	if err := O.drv.checkExec(func()  /*line :74:35*/_Ctype_int /*line :74:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :75:40*/O.dpiObject; _cgo1 := /*line :75:53*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :75:73*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :75:93*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :75:107*/_Cfunc_dpiObject_getAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		return fmt.Errorf("getAttributeValue(%q, obj=%s, attr=%+v, typ=%d): %w", name, O.Name, attr.dpiObjectAttr, data.NativeTypeNum, err)
	}
	if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("getAttributeValue", "dpiObject", fmt.Sprintf("%p", O.dpiObject),
			attr.Name, fmt.Sprintf("%p", attr.dpiObjectAttr),
			"nativeType", data.NativeTypeNum, "oracleType", attr.OracleTypeNum,
			"p", fmt.Sprintf("%p", data))
	}
	return nil
}

// SetAttribute sets the named attribute with data.
func (O *Object) SetAttribute(name string, data *Data) error {
	if !strings.Contains(name, `"`) {
		name = strings.ToUpper(name)
	}
	attr, ok := O.Attributes[name]
	if !ok {
		return fmt.Errorf("set %s[%s]: %w (have: %q)", O, name, ErrNoSuchKey, O.AttributeNames())
	}
	if data.NativeTypeNum == 0 {
		if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelWarn) {
			logger.Warn("WARN setAttributeValue", "attr.NativeTypeNum", attr.NativeTypeNum, "data.NativeTypeNum", data.NativeTypeNum)
		}
		data.NativeTypeNum = attr.NativeTypeNum
		data.ObjectType = attr.ObjectType
		data.dpiData.isNull = 1
	}
	if err := O.drv.checkExec(func()  /*line :105:35*/_Ctype_int /*line :105:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :106:40*/O.dpiObject; _cgo1 := /*line :106:53*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :106:73*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :106:93*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :106:107*/_Cfunc_dpiObject_setAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		return fmt.Errorf("dpiObject_setAttributeValue NativeTypeNum=%d ObjectType=%v: %w", data.NativeTypeNum, data.ObjectType, err)
	}
	return nil
}

// Set is a convenience function to set the named attribute with the given value.
func (O *Object) Set(name string, v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.SetAttribute(name, data)
	}
	d := scratch.Get()
	defer scratch.Put(d)
	if err := d.Set(v); err != nil {
		return err
	}
	return O.SetAttribute(name, d)
}

// ResetAttributes prepare all attributes for use the object as IN parameter
func (O *Object) ResetAttributes() error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	data := scratch.Get()
	defer scratch.Put(data)
	for _, attr := range O.Attributes {
		data.reset()
		data.NativeTypeNum = attr.NativeTypeNum
		data.ObjectType = attr.ObjectType
		if attr.NativeTypeNum == ( /*line :137:28*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :137:50*/) && attr.OracleTypeNum == ( /*line :137:77*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :137:100*/) {
			a := make([]byte, attr.Precision)
			( /*line :139:4*/_Cfunc_dpiData_setBytes /*line :139:21*/)(&data.dpiData, (* /*line :139:40*/_Ctype_char /*line :139:46*/)(unsafe.Pointer(&a[0])),  /*line :139:72*/_Ctype_uint32_t /*line :139:82*/(attr.Precision))
		}
		if func() _Ctype_int{ _cgo0 := /*line :141:36*/O.dpiObject; _cgo1 := /*line :141:49*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :141:69*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :141:89*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :141:103*/_Cfunc_dpiObject_setAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :141:107*/_Ciconst_DPI_FAILURE /*line :141:119*/) {
			return O.drv.getError()
		}
	}

	return nil
}

// Get scans the named attribute into dest, and returns it.
func (O *Object) Get(name string) (interface{}, error) {
	d := scratch.Get()
	defer scratch.Put(d)
	if err := O.GetAttribute(d, name); err != nil {
		return nil, err
	}
	isObject := d.IsObject()
	ot := O.Attributes[name].ObjectType
	if isObject {
		d.ObjectType = ot
	}
	v := d.Get()
	if !isObject {
		return maybeString(v, ot), nil
	}
	sub := v.(*Object)
	if sub != nil && sub.ObjectType.CollectionOf != nil {
		return &ObjectCollection{Object: sub}, nil
	}
	return sub, nil
}

func maybeString(v interface{}, ot *ObjectType) interface{} {
	switch ot.OracleTypeNum {
	case ( /*line :174:7*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :174:31*/), ( /*line :174:34*/_Ciconst_DPI_ORACLE_TYPE_NVARCHAR /*line :174:59*/),
		( /*line :175:3*/_Ciconst_DPI_ORACLE_TYPE_CHAR /*line :175:24*/), ( /*line :175:27*/_Ciconst_DPI_ORACLE_TYPE_NCHAR /*line :175:49*/),
		( /*line :176:3*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :176:26*/),
		( /*line :177:3*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :177:24*/), ( /*line :177:27*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :177:49*/),
		( /*line :178:3*/_Ciconst_DPI_ORACLE_TYPE_LONG_VARCHAR /*line :178:32*/), ( /*line :178:35*/_Ciconst_DPI_ORACLE_TYPE_LONG_NVARCHAR /*line :178:65*/):

		if b, ok := v.([]byte); ok {
			return string(b)
		}
	}
	return v
}

// ObjectRef implements userType interface.
func (O *Object) ObjectRef() *Object {
	return O
}

// Collection returns &ObjectCollection{Object: O} iff the Object is a collection.
// Otherwise it returns nil.
func (O *Object) Collection() ObjectCollection {
	if O.ObjectType.CollectionOf == nil {
		return ObjectCollection{}
	}
	return ObjectCollection{Object: O}
}

// Close releases a reference to the object.
func (O *Object) Close() error {
	if O == nil {
		return nil
	}
	obj := O.dpiObject
	O.dpiObject = nil
	if obj == nil {
		return nil
	}
	logger := getLogger(context.TODO())
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("Object.Close", "object", fmt.Sprintf("%p", obj))
	}

	// Close sub-objects first
	for _, a := range O.Attributes {
		if !a.IsObject() {
			continue
		}
		if err := func() error {
			data := scratch.Get()
			defer scratch.Put(data)
			if err := O.GetAttribute(data, a.Name); err != nil {
				return fmt.Errorf("get attribute %q: %w", a.Name, err)
			}
			obj := data.GetObject()
			if obj == nil {
				return nil
			}
			if logger != nil && logger.Enabled(context.TODO(), slog.LevelInfo) {
				logger.Info("Object.Close close sub-object", "attribute", a.Name, "object", fmt.Sprintf("%p", obj))
			}

			return obj.Close()
		}(); err != nil && logger != nil {
			logger.Error("Close sub-object", "name", a.Name, "error", err)
		}
	}
	// Reset all attributes
	O.ResetAttributes()

	if err := O.drv.checkExec(func()  /*line :243:35*/_Ctype_int /*line :243:40*/ { return func() _Ctype_int{ _cgo0 := /*line :243:70*/obj; _cgoCheckPointer(_cgo0, nil); return /*line :243:74*/_Cfunc_dpiObject_release(_cgo0); }() }); err != nil {
		return fmt.Errorf("error on close object: %w", err)
	}

	return nil
}

// AsMap is a convenience function that returns the object's attributes as a map[string]interface{}.
// It allocates, so use it as a guide how to implement your own converter function.
//
// If recursive is true, then the embedded objects are converted, too, recursively.
func (O *Object) AsMap(recursive bool) (map[string]interface{}, error) {
	if O == nil || O.dpiObject == nil {
		return nil, nil
	}
	logger := getLogger(context.TODO())
	m := make(map[string]interface{}, len(O.ObjectType.Attributes))
	data := scratch.Get()
	defer scratch.Put(data)
	for a, ot := range O.ObjectType.Attributes {
		if err := O.GetAttribute(data, a); err != nil {
			return m, fmt.Errorf("%q: %w", a, err)
		}
		d := data.Get()
		if d == nil {
			continue
		}
		if !data.IsObject() {
			d = maybeString(d, ot.ObjectType)
		}
		m[a] = d
		if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("AsMap", "attribute", a, "data", fmt.Sprintf("%#v", d), "type", fmt.Sprintf("%T", d), "recursive", recursive)
		}
		if !recursive {
			continue
		}
		if sub, ok := d.(*Object); ok && sub != nil && sub.ObjectType != nil {
			var err error
			if sub.ObjectType.CollectionOf == nil {
				if m[a], err = sub.AsMap(recursive); err != nil {
					return m, fmt.Errorf("%q.AsMap: %w", a, err)
				}
				continue
			}
			if sub.ObjectType.CollectionOf.Attributes == nil {
				if m[a], err = sub.Collection().AsSlice(nil); err != nil {
					return m, fmt.Errorf("%q.AsSlice: %w", a, err)
				}
			} else if m[a], err = sub.Collection().AsMapSlice(recursive); err != nil {
				return m, fmt.Errorf("%q.AsMapSlice: %w", a, err)
			}
		}
	}
	return m, nil
}

// ToJSON writes the Object as JSON into the io.Writer.
func (O *Object) ToJSON(w io.Writer) error {
	if O == nil || O.ObjectType == nil {
		_, err := io.WriteString(w, "nil")
		return err
	}
	if O.ObjectType.CollectionOf != nil {
		return O.Collection().ToJSON(w)
	}
	bw := bufio.NewWriter(w)
	defer bw.Flush()
	if err := bw.WriteByte('{'); err != nil {
		return err
	}
	data := scratch.Get()
	defer scratch.Put(data)
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	keys := make([]string, 0, len(O.ObjectType.Attributes))
	for a := range O.ObjectType.Attributes {
		keys = append(keys, a)
	}
	sort.Strings(keys)
	for i, a := range keys {
		if err := O.GetAttribute(data, a); err != nil {
			return fmt.Errorf("%q: %w", a, err)
		}
		if i != 0 {
			if err := bw.WriteByte(','); err != nil {
				return err
			}
		}
		fmt.Fprintf(bw, "%q:", a)
		d := data.Get()
		if data.IsObject() {
			if err := d.(*Object).ToJSON(bw); err != nil {
				return fmt.Errorf("%q: %w", a, err)
			}
			continue
		}
		d = maybeString(d, O.ObjectType.Attributes[a].ObjectType)
		buf.Reset()
		if err := enc.Encode(d); err != nil {
			return fmt.Errorf("%q: %#v: %w", a, d, err)
		}
		if _, err := bw.Write(bytes.TrimSpace(buf.Bytes())); err != nil {
			return fmt.Errorf("%q: %w", a, err)
		}
	}
	return bw.WriteByte('}')
}

func (O *Object) String() string {
	if O == nil {
		return ""
	}
	var buf strings.Builder
	_, _ = buf.WriteString(O.ObjectType.String())
	_ = O.ToJSON(&buf)
	return buf.String()
}

// ObjectCollection represents a Collection of Objects - itself an Object, too.
type ObjectCollection struct {
	*Object
}

// ErrNotCollection is returned when the Object is not a collection.
var ErrNotCollection = errors.New("not collection")

// ErrNotExist is returned when the collection's requested element does not exist.
var ErrNotExist = errors.New("not exist")

// AsMapSlice retrieves the collection into a []map[string]interface{}.
// If recursive is true, then all subsequent Objects/ObjectsCollections are translated.
//
// This is horrendously inefficient, use it only as a guide!
func (O ObjectCollection) AsMapSlice(recursive bool) ([]map[string]interface{}, error) {
	length, err := O.Len()
	if err != nil {
		return nil, fmt.Errorf("Len: %w", err)
	}
	m := make([]map[string]interface{}, 0, length)
	for curr, err := O.First(); err == nil; curr, err = O.Next(curr) {
		if v, err := O.Get(curr); err != nil {
			return m, fmt.Errorf("Get(%v): %w", curr, err)
		} else if v == nil {
			m = append(m, nil)
		} else if o, ok := v.(*Object); ok {
			r, err := o.AsMap(recursive)
			if err != nil {
				return m, fmt.Errorf("[%d](%v).AsMap: %w", curr, v, err)
			}
			m = append(m, r)
		}
	}
	return m, nil
}

// FromSlice read from a slice of primitives.
func (O ObjectCollection) FromSlice(v []interface{}) error {
	if O.dpiObject == nil {
		return nil
	}
	logger := getLogger(context.TODO())

	data := scratch.Get()

	for i, o := range v {
		if logger != nil {
			logger.Debug("FromSlice", "index", i)
		}

		if err := data.Set(o); err != nil {
			return err
		}
		if err := O.AppendData(data); err != nil {
			return err
		}
	}

	return nil
}

// FromMap populates the Object starting from a map, according to the Object's Attributes.
func (O *Object) FromMap(recursive bool, m map[string]interface{}) error {
	if O == nil || O.dpiObject == nil {
		return nil
	}
	logger := getLogger(context.TODO())

	for a, ot := range O.ObjectType.Attributes {
		v := m[a]
		if v == nil {
			continue
		}
		if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("FromMap", "attribute", a, "value", v, "type", fmt.Sprintf("%T", v), "recursive", recursive, "ot", ot.ObjectType)
		}
		if ot.ObjectType.CollectionOf != nil { // Collection case
			if err := func() error {
				coll, err := ot.NewCollection()
				if err != nil {
					return fmt.Errorf("%q.FromMap: %w", a, err)
				}
				defer coll.Close()
				switch v := v.(type) {
				case []map[string]interface{}:
					if err := coll.FromMapSlice(recursive, v); err != nil {
						return fmt.Errorf("%q.FromMapSlice: %w", a, err)
					}
				case []interface{}:
					if ot.IsObject() {
						m := make([]map[string]interface{}, 0, len(v))
						for _, e := range v {
							m = append(m, e.(map[string]interface{}))
						}
						if err := coll.FromMapSlice(recursive, m); err != nil {
							return fmt.Errorf("%q.FromMapSlice: %w", a, err)
						}
					} else {
						data := scratch.Get()
						defer scratch.Put(data)
						for _, e := range v {
							if err := data.Set(e); err != nil {
								return err
							}
							if err := coll.AppendData(data); err != nil {
								return err
							}
						}
					}
				default:
					return fmt.Errorf("%q is a collection, needs []interface{} or []map[string]interface{}, got %T", a, v)
				}
				if err = O.Set(a, coll); err != nil {
					return fmt.Errorf("%q.Set(%v): %w", a, coll, err)
				}
				return nil
			}(); err != nil {
				return err
			}
		} else if ot.ObjectType.Attributes != nil { // Object case
			newO, err := ot.NewObject()
			if err != nil {
				return fmt.Errorf("%q.FromMap: %w", a, err)
			}
			if err := newO.FromMap(recursive, v.(map[string]interface{})); err != nil {
				newO.Close()
				return fmt.Errorf("%q.FromMap: %w", a, err)
			}
			err = O.Set(a, newO)
			newO.Close()
			if err != nil {
				return fmt.Errorf("%q.Set(%v): %w", a, newO.ObjectType, err)
			}
		} else if err := O.Set(a, v); err != nil { // Plain type case
			return err
		}
	}
	return nil
}

func (O *Object) FromJSON(dec *json.Decoder) error {
	tok, err := dec.Token()
	if err != nil {
		if err == io.EOF {
			return nil
		}
		return err
	}
	wantDelim := tok == json.Delim('{')
	logger := getLogger(context.TODO())
	first := true
	for {
		if first && wantDelim || !first {
			first = false
			if tok, err = dec.Token(); err != nil {
				if err == io.EOF {
					break
				}
				return err
			}
		}
		k, ok := tok.(string)
		if !ok {
			return fmt.Errorf("wanted key (string), got %v (%T)", tok, tok)
		}
		k = strings.ToUpper(k)
		a, ok := O.ObjectType.Attributes[k]
		if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("attribute", "k", k, "a", a)
		}
		if !ok {
			return fmt.Errorf("key %q not found", k)
		}
		var v interface{}
		var C func() error
		if a.ObjectType.CollectionOf != nil {
			coll, err := a.ObjectType.NewCollection()
			if err != nil {
				return fmt.Errorf("%q.%s.NewCollection: %w", k, a.ObjectType, err)
			}
			if err = coll.FromJSON(dec); err != nil {
				return fmt.Errorf("%q.FromJSON: %w", k, err)
			}
			v = coll
			C = coll.Close
		} else if a.ObjectType.IsObject() {
			obj, err := a.ObjectType.NewObject()
			if err != nil {
				return fmt.Errorf("%q.%s.NewObject: %w", k, a.ObjectType, err)
			}
			if err = obj.FromJSON(dec); err != nil {
				return fmt.Errorf("%q.FromJSON: %w", k, err)
			}
			v = obj
			C = obj.Close
		} else {
			if tok, err = dec.Token(); err != nil {
				return err
			}
			v = tok
		}
		err = O.Set(k, v)
		if C != nil {
			if closeErr := C(); err == nil {
				err = closeErr
			}
		}
		if err != nil {
			return fmt.Errorf("%q.Set(%v): %w", k, v, err)
		}
		if !dec.More() {
			break
		}
	}
	if wantDelim {
		_, err = dec.Token()
	}
	return err
}

// FromMapSlice populates the ObjectCollection starting from a slice of map, according to the Collections's Attributes.
func (O ObjectCollection) FromMapSlice(recursive bool, m []map[string]interface{}) error {
	if O.dpiObject == nil {
		return nil
	}
	logger := getLogger(context.TODO())

	for i, o := range m {
		if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("FromMapSlice", "index", i, "recursive", recursive)
		}
		elt, err := O.ObjectType.CollectionOf.NewObject()
		if err != nil {
			return fmt.Errorf("%d.FromMapSlice: %w", i, err)
		}
		if err := elt.FromMap(recursive, o); err != nil {
			elt.Close()
			return fmt.Errorf("%d.FromMapSlice: %w", i, err)
		}
		err = O.Append(elt)
		elt.Close()
		if err != nil {
			return err
		}
	}
	return nil
}

func (O ObjectCollection) FromJSON(dec *json.Decoder) error {
	tok, err := dec.Token()
	if err != nil {
		if err == io.EOF {
			return nil
		}
		return err
	}
	wantDelim := tok == json.Delim('[')
	for {
		elt, err := O.ObjectType.CollectionOf.NewObject()
		if err != nil {
			return err
		}
		err = elt.FromJSON(dec)
		if err != nil {
			elt.Close()
			return err
		}
		err = O.Append(elt)
		elt.Close()
		if err != nil {
			return err
		}
		if !dec.More() {
			break
		}
	}
	if wantDelim {
		_, err = dec.Token()
	}
	return err
}

// AsSlice retrieves the collection into a slice.
func (O ObjectCollection) AsSlice(dest interface{}) (interface{}, error) {
	var dr reflect.Value
	needsInit := dest == nil
	if !needsInit {
		dr = reflect.ValueOf(dest)
	}
	d := scratch.Get()
	defer scratch.Put(d)
	for i, err := O.First(); err == nil; i, err = O.Next(i) {
		if O.CollectionOf.IsObject() {
			d.ObjectType = O.CollectionOf
		}
		if err = O.GetItem(d, i); err != nil {
			return dest, err
		}
		v := d.Get()
		if !d.IsObject() {
			v = maybeString(v, O.CollectionOf)
		}
		vr := reflect.ValueOf(v)
		if needsInit {
			needsInit = false
			length, lengthErr := O.Len()
			if lengthErr != nil {
				return dr.Interface(), lengthErr
			}
			dr = reflect.MakeSlice(reflect.SliceOf(vr.Type()), 0, length)
		}
		dr = reflect.Append(dr, vr)
	}
	if !dr.IsValid() {
		return nil, nil
	}
	return dr.Interface(), nil
}

// ToJSON writes the ObjectCollection as JSON to the io.Writer.
func (O ObjectCollection) ToJSON(w io.Writer) error {
	var notFirst bool
	bw := bufio.NewWriter(w)
	defer bw.Flush()
	if err := bw.WriteByte('['); err != nil {
		return err
	}
	for curr, err := O.First(); err == nil; curr, err = O.Next(curr) {
		if notFirst {
			if err = bw.WriteByte(','); err != nil {
				return err
			}
		} else {
			notFirst = true
		}
		if v, err := O.Get(curr); err != nil {
			return fmt.Errorf("Get(%v): %w", curr, err)
		} else if v == nil {
			if _, err = bw.WriteString("nil"); err != nil {
				return err
			}
		} else if o, ok := v.(*Object); ok {
			if err = o.ToJSON(bw); err != nil {
				return err
			}
		}
	}
	return bw.WriteByte(']')
}

func (O ObjectCollection) String() string {
	if O.Object == nil {
		return ""
	}
	var buf strings.Builder
	_, _ = buf.WriteString(O.Object.ObjectType.String())
	_ = O.ToJSON(&buf)
	return buf.String()
}

// AppendData to the collection.
func (O ObjectCollection) AppendData(data *Data) error {
	if err := O.drv.checkExec(func()  /*line :725:35*/_Ctype_int /*line :725:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :726:36*/O.dpiObject; var _cgo1 _Ctype_dpiNativeTypeNum = /*line :726:49*/data.NativeTypeNum; var _cgo2 *_Ctype_struct_dpiData = /*line :726:69*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); return /*line :726:83*/_Cfunc_dpiObject_appendElement(_cgo0, _cgo1, _cgo2); }()
	}); err != nil {
		return fmt.Errorf("append(%d): %w", data.NativeTypeNum, err)
	}
	return nil
}

// Append v to the collection.
func (O ObjectCollection) Append(v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.AppendData(data)
	}
	d := scratch.Get()
	defer scratch.Put(d)
	if err := d.Set(v); err != nil {
		return err
	}
	return O.AppendData(d)
}

// AppendObject adds an Object to the collection.
func (O ObjectCollection) AppendObject(obj *Object) error {
	d := scratch.Get()
	defer scratch.Put(d)
	d.ObjectType = obj.ObjectType
	d.NativeTypeNum = ( /*line :751:20*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :751:43*/)
	d.SetObject(obj)
	return O.Append(d)
}

// Delete i-th element of the collection.
func (O ObjectCollection) Delete(i int) error {
	if err := O.drv.checkExec(func()  /*line :758:35*/_Ctype_int /*line :758:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :759:43*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t /*line :759:65*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :759:69*/_Cfunc_dpiObject_deleteElementByIndex(_cgo0, _cgo1); }()
	}); err != nil {
		return fmt.Errorf("delete(%d): %w", i, err)
	}
	return nil
}

// GetItem gets the i-th element of the collection into data.
func (O ObjectCollection) GetItem(data *Data, i int) error {
	if data == nil {
		panic("data cannot be nil")
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	idx :=  /*line :775:9*/_Ctype_int32_t /*line :775:18*/(i)
	var exists  /*line :776:13*/_Ctype_int /*line :776:18*/
	if func() _Ctype_int{ _cgo0 := /*line :777:41*/O.dpiObject; var _cgo1 _Ctype_int32_t = /*line :777:54*/idx; var _cgo2 *_Ctype_int = /*line :777:59*/&exists; _cgoCheckPointer(_cgo0, nil); return /*line :777:67*/_Cfunc_dpiObject_getElementExistsByIndex(_cgo0, _cgo1, _cgo2); }() == ( /*line :777:71*/_Ciconst_DPI_FAILURE /*line :777:83*/) {
		return fmt.Errorf("exists(%d): %w", idx, O.drv.getError())
	}
	if exists == 0 {
		return ErrNotExist
	}
	data.reset()
	data.ObjectType = O.CollectionOf
	if O.CollectionOf != nil {
		data.NativeTypeNum = O.CollectionOf.NativeTypeNum
		data.implicitObj = true
	}
	if func() _Ctype_int{ _cgo0 := /*line :789:40*/O.dpiObject; var _cgo1 _Ctype_int32_t = /*line :789:53*/idx; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :789:58*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :789:78*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); return /*line :789:92*/_Cfunc_dpiObject_getElementValueByIndex(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :789:96*/_Ciconst_DPI_FAILURE /*line :789:108*/) {
		return fmt.Errorf("get(%d[%d]): %w", idx, data.NativeTypeNum, O.drv.getError())
	}
	return nil
}

// Get the i-th element of the collection.
func (O ObjectCollection) Get(i int) (interface{}, error) {
	data := scratch.Get()
	defer scratch.Put(data)
	err := O.GetItem(data, i)
	return data.Get(), err
}

// SetItem sets the i-th element of the collection with data.
func (O ObjectCollection) SetItem(i int, data *Data) error {
	if err := O.drv.checkExec(func()  /*line :805:35*/_Ctype_int /*line :805:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :806:45*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t /*line :806:67*/(i); var _cgo2 _Ctype_dpiNativeTypeNum = /*line :806:72*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :806:92*/&data.dpiData; _cgoCheckPointer(_cgo0, nil); return /*line :806:106*/_Cfunc_dpiObject_setElementValueByIndex(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		return fmt.Errorf("set(%d[%d]): %w", i, data.NativeTypeNum, err)
	}
	return nil
}

// Set the i-th element of the collection with value.
func (O ObjectCollection) Set(i int, v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.SetItem(i, data)
	}
	d := scratch.Get()
	defer scratch.Put(d)
	if err := d.Set(v); err != nil {
		return err
	}
	return O.SetItem(i, d)
}

// First returns the first element's index of the collection.
func (O ObjectCollection) First() (int, error) {
	var exists  /*line :828:13*/_Ctype_int /*line :828:18*/
	var idx  /*line :829:10*/_Ctype_int32_t /*line :829:19*/
	if err := O.drv.checkExec(func()  /*line :830:35*/_Ctype_int /*line :830:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :831:36*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :831:49*/&idx; var _cgo2 *_Ctype_int = /*line :831:55*/&exists; _cgoCheckPointer(_cgo0, nil); return /*line :831:63*/_Cfunc_dpiObject_getFirstIndex(_cgo0, _cgo1, _cgo2); }()
	}); err != nil {
		return 0, fmt.Errorf("first: %w", err)
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Last returns the index of the last element.
func (O ObjectCollection) Last() (int, error) {
	var exists  /*line :843:13*/_Ctype_int /*line :843:18*/
	var idx  /*line :844:10*/_Ctype_int32_t /*line :844:19*/
	if err := O.drv.checkExec(func()  /*line :845:35*/_Ctype_int /*line :845:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :846:35*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :846:48*/&idx; var _cgo2 *_Ctype_int = /*line :846:54*/&exists; _cgoCheckPointer(_cgo0, nil); return /*line :846:62*/_Cfunc_dpiObject_getLastIndex(_cgo0, _cgo1, _cgo2); }()
	}); err != nil {
		return 0, fmt.Errorf("last: %w", err)
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Next returns the succeeding index of i.
func (O ObjectCollection) Next(i int) (int, error) {
	var exists  /*line :858:13*/_Ctype_int /*line :858:18*/
	var idx  /*line :859:10*/_Ctype_int32_t /*line :859:19*/
	if err := O.drv.checkExec(func()  /*line :860:35*/_Ctype_int /*line :860:40*/ {
		return func() _Ctype_int{ _cgo0 := /*line :861:35*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t /*line :861:57*/(i); var _cgo2 *_Ctype_int32_t = /*line :861:62*/&idx; var _cgo3 *_Ctype_int = /*line :861:68*/&exists; _cgoCheckPointer(_cgo0, nil); return /*line :861:76*/_Cfunc_dpiObject_getNextIndex(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		return 0, fmt.Errorf("next(%d): %w", i, err)
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Len returns the length of the collection.
func (O ObjectCollection) Len() (int, error) {
	var size  /*line :873:11*/_Ctype_int32_t /*line :873:20*/
	if err := O.drv.checkExec(func()  /*line :874:35*/_Ctype_int /*line :874:40*/ { return func() _Ctype_int{ _cgo0 := /*line :874:70*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :874:83*/&size; _cgoCheckPointer(_cgo0, nil); return /*line :874:89*/_Cfunc_dpiObject_getSize(_cgo0, _cgo1); }() }); err != nil {
		return 0, fmt.Errorf("len: %w", err)
	}
	return int(size), nil
}

// Trim the collection to n.
func (O ObjectCollection) Trim(n int) error {
	return O.drv.checkExec(func()  /*line :882:32*/_Ctype_int /*line :882:37*/ { return func() _Ctype_int{ _cgo0 := /*line :882:64*/O.dpiObject; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :882:87*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :882:91*/_Cfunc_dpiObject_trim(_cgo0, _cgo1); }() })
}

// ObjectType holds type info of an Object.
type ObjectType struct {
	CollectionOf                        *ObjectType
	Attributes                          map[string]ObjectAttribute
	drv                                 *drv
	dpiObjectType                       * /*line :890:39*/_Ctype_dpiObjectType /*line :890:54*/
	Schema, Name, PackageName           string
	Annotations                         []Annotation
	DBSize, ClientSizeInBytes, CharSize int
	mu                                  sync.RWMutex
	OracleTypeNum                        /*line :895:38*/_Ctype_dpiOracleTypeNum /*line :895:56*/
	NativeTypeNum                        /*line :896:38*/_Ctype_dpiNativeTypeNum /*line :896:56*/
	DomainAnnotation
	Precision   int16
	Scale       int8
	FsPrecision uint8
}

// AttributeNames returns the Attributes' names ordered as on the database (by ObjectAttribute.Sequence).
func (t *ObjectType) AttributeNames() []string {
	if t == nil {
		return nil
	}
	names := make([]string, len(t.Attributes))
	for k, v := range t.Attributes {
		names[v.Sequence] = k
	}
	return names
}

func (t *ObjectType) String() string {
	if t == nil {
		return ""
	}
	if t.Schema == "" {
		return t.Name
	}
	return t.Schema + "." + t.Name
}

func (t *ObjectType) IsObject() bool { return t != nil && t.NativeTypeNum == ( /*line :925:78*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :925:101*/) }

// FullName returns the object's name with the schame prepended.
func (t *ObjectType) FullName() string {
	if t == nil {
		return ""
	}
	if t.Schema == "" {
		return t.Name
	}
	return t.Schema + "." + t.Name
}

// GetObjectType returns the ObjectType of a name.
//
// The name is uppercased! Because here Oracle seems to be case-sensitive.
// To leave it as is, enclose it in "-s!
func (c *conn) GetObjectType(name string) (*ObjectType, error) {
	if !strings.Contains(name, "\"") {
		name = strings.ToUpper(name)
	}
	if name == "" {
		return nil, errors.New("empty name")
	}
	c.mu.RLock()
	defer c.mu.RUnlock()
	if c.dpiConn == nil {
		return nil, driver.ErrBadConn
	}

	if t := c.objTypes[name]; t != nil {
		if t.drv != nil {
			//fmt.Println("GetObjectType CACHED", name)
			return t, nil
		}
		//fmt.Printf("GetObjectType(%q) %p is CLOSED on %p\n", name, t, c)
		// t is closed
		delete(c.objTypes, name)
		delete(c.objTypes, t.FullName())
	}

	objType := (* /*line :966:15*/_Ctype_dpiObjectType /*line :966:30*/)(( /*line :966:32*/_Cfunc__CMalloc /*line :966:39*/)(( /*line :966:41*/_Ciconst_sizeof_void /*line :966:53*/)))
	cName := ( /*line :967:11*/_Cfunc_CString /*line :967:19*/)(name)
	err := c.checkExec(func()  /*line :968:28*/_Ctype_int /*line :968:33*/ {
		return func() _Ctype_int{ _cgo0 := /*line :969:34*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :969:45*/cName; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :969:62*/(len(name)); _cgoBase3 := /*line :969:75*/&objType; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :969:84*/_Cfunc_dpiConn_getObjectType(_cgo0, _cgo1, _cgo2, _cgo3); }()
	})
	func() { _cgo0 := /*line :971:9*/unsafe.Pointer(cName); _cgoCheckPointer(_cgo0, nil); /*line :971:31*/_Cfunc_free(_cgo0); }()
	if err != nil {
		func() { _cgo0 := /*line :973:10*/unsafe.Pointer(objType); _cgoCheckPointer(_cgo0, nil); /*line :973:34*/_Cfunc_free(_cgo0); }()
		if strings.Contains(err.Error(), "DPI-1062: unexpected OCI return value 1041 in function dpiConn_getObjectType") {
			err = fmt.Errorf("getObjectType(%q) conn=%p: %+v: %w", name, c.dpiConn, err, driver.ErrBadConn)
			_ = c.closeNotLocking()
			return nil, err
		}
		return nil, fmt.Errorf("getObjectType(%q) conn=%p: %w", name, c.dpiConn, err)
	}
	t := &ObjectType{drv: c.drv, dpiObjectType: objType}
	if err = t.init(c.objTypes); err != nil {
		return t, err
	}
	if name != t.FullName() {
		c.objTypes[name] = t
	}
	//fmt.Printf("GetObjectType(%q/%q) NEW: %p\n", name, t.FullName(), t)
	return t, nil
}

var errNilObjectType = errors.New("ObjectType is nil")

// NewObject returns a new Object with ObjectType type.
//
// As with all Objects, you MUST call Close on it when not needed anymore!
func (t *ObjectType) NewObject() (*Object, error) {
	if t == nil {
		return nil, errNilObjectType
	}
	logger := getLogger(context.TODO())
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("NewObject", "name", t.Name)
	}
	obj := (* /*line :1005:11*/_Ctype_dpiObject /*line :1005:22*/)(( /*line :1005:24*/_Cfunc__CMalloc /*line :1005:31*/)(( /*line :1005:33*/_Ciconst_sizeof_void /*line :1005:45*/)))
	t.mu.RLock()
	err := t.drv.checkExec(func()  /*line :1007:32*/_Ctype_int /*line :1007:37*/ { return func() _Ctype_int{ _cgo0 := /*line :1007:76*/t.dpiObjectType; _cgoBase1 := /*line :1007:93*/&obj; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1007:98*/_Cfunc_dpiObjectType_createObject(_cgo0, _cgo1); }() })
	t.mu.RUnlock()
	if err != nil {
		func() { _cgo0 := /*line :1010:10*/unsafe.Pointer(obj); _cgoCheckPointer(_cgo0, nil); /*line :1010:30*/_Cfunc_free(_cgo0); }()
		return nil, err
	}
	O := &Object{ObjectType: t, dpiObject: obj}

	if warnMissingObjectClose && guardWithFinalizers.Load() {
		runtime.SetFinalizer(O, func(O *Object) {
			if O == nil || O.dpiObject == nil {
				return
			}
			fmt.Printf("WARN Object %v is not closed\n", O)
			O.Close()
		})
	}
	// https://github.com/oracle/odpi/issues/112#issuecomment-524479532
	return O, O.ResetAttributes()
}

// NewCollection returns a new Collection object with ObjectType type.
// If the ObjectType is not a Collection, it returns ErrNotCollection error.
func (t *ObjectType) NewCollection() (ObjectCollection, error) {
	if t.CollectionOf == nil {
		return ObjectCollection{}, ErrNotCollection
	}
	O, err := t.NewObject()
	if err != nil {
		return ObjectCollection{}, err
	}
	return ObjectCollection{Object: O}, nil
}

// Close releases a reference to the object type.
func (t *ObjectType) Close() error {
	if t == nil {
		return nil
	}
	//var a [4096]byte
	//stack := a[:runtime.Stack(a[:], false)]
	//fmt.Printf("ObjectType %p[%q].Close(): %s\n", t, t.Name, stack)

	t.mu.Lock()
	defer t.mu.Unlock()
	attributes, cof, ot, drv := t.Attributes, t.CollectionOf, t.dpiObjectType, t.drv
	t.Attributes, t.CollectionOf, t.dpiObjectType, t.drv = nil, nil, nil, nil

	if ot == nil {
		return nil
	}

	logger := getLogger(context.TODO())
	if cof != nil {
		if err := cof.Close(); err != nil && logger != nil {
			logger.Error("ObjectType.Close CollectionOf.Close", "name", t.Name, "collectionOf", cof.Name, "error", err)
		}
	}

	for _, attr := range attributes {
		if err := attr.Close(); err != nil && logger != nil {
			logger.Error("ObjectType.Close attr.Close", "name", t.Name, "attr", attr.Name, "error", err)
		}
	}

	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("ObjectType.Close", "name", t.Name)
	}
	if err := drv.checkExec(func()  /*line :1075:33*/_Ctype_int /*line :1075:38*/ { return func() _Ctype_int{ _cgo0 := /*line :1075:72*/ot; _cgoCheckPointer(_cgo0, nil); return /*line :1075:75*/_Cfunc_dpiObjectType_release(_cgo0); }() }); err != nil {
		return fmt.Errorf("error releasing object type: %w", err)
	}

	return nil
}

func wrapObject(c *conn, objectType * /*line :1082:38*/_Ctype_dpiObjectType /*line :1082:53*/, object * /*line :1082:63*/_Ctype_dpiObject /*line :1082:74*/) (*Object, error) {
	if objectType == nil {
		return nil, errors.New("objectType is nil")
	}
	if err := c.checkExec(func()  /*line :1086:31*/_Ctype_int /*line :1086:36*/ { return func() _Ctype_int{ _cgo0 := /*line :1086:65*/object; _cgoCheckPointer(_cgo0, nil); return /*line :1086:72*/_Cfunc_dpiObject_addRef(_cgo0); }() }); err != nil {
		return nil, err
	}
	o := &Object{
		ObjectType: &ObjectType{dpiObjectType: objectType, drv: c.drv},
		dpiObject:  object,
	}
	c.mu.RLock()
	err := o.ObjectType.init(c.objTypes)
	c.mu.RUnlock()
	if err != nil {
		_ = o.Close()
		return nil, err
	}
	return o, nil
}

func (t *ObjectType) init(cache map[string]*ObjectType) error {
	if t.drv == nil {
		panic("conn is nil")
	}
	if t.Name != "" && t.Attributes != nil {
		return nil
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	t.mu.RLock()
	d := t.dpiObjectType
	t.mu.RUnlock()
	if d == nil {
		return nil
	}
	var info  /*line :1120:11*/_Ctype_dpiObjectTypeInfo /*line :1120:30*/
	if func() _Ctype_int{ _cgo0 := /*line :1121:29*/d; _cgoBase1 := /*line :1121:32*/&info; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1121:38*/_Cfunc_dpiObjectType_getInfo(_cgo0, _cgo1); }() == ( /*line :1121:42*/_Ciconst_DPI_FAILURE /*line :1121:54*/) {
		return fmt.Errorf("%v.getInfo: %w", t, t.drv.getError())
	}
	t.Schema = ( /*line :1124:13*/_Cfunc_GoStringN /*line :1124:23*/)(info.schema,  /*line :1124:38*/_Ctype_int /*line :1124:43*/(info.schemaLength))
	t.Name = ( /*line :1125:11*/_Cfunc_GoStringN /*line :1125:21*/)(info.name,  /*line :1125:34*/_Ctype_int /*line :1125:39*/(info.nameLength))
	t.PackageName = ( /*line :1126:18*/_Cfunc_GoStringN /*line :1126:28*/)(info.packageName,  /*line :1126:48*/_Ctype_int /*line :1126:53*/(info.packageNameLength))
	t.CollectionOf = nil

	if info.isCollection == 1 {
		t.CollectionOf = &ObjectType{drv: t.drv}
		if err := t.CollectionOf.fromDataTypeInfo(info.elementTypeInfo, cache); err != nil {
			return err
		}
		if t.CollectionOf.Name == "" {
			t.CollectionOf.Schema = t.Schema
			t.CollectionOf.Name = t.Name
		}
		if t.CollectionOf.dpiObjectType != nil {
			func() _Ctype_int{ _cgo0 := /*line :1139:27*/t.CollectionOf.dpiObjectType; _cgoCheckPointer(_cgo0, nil); return /*line :1139:56*/_Cfunc_dpiObjectType_addRef(_cgo0); }()
		}
	}
	ctx := context.TODO()
	logger := getLogger(ctx)
	if logger != nil && logger.Enabled(ctx, slog.LevelDebug) {
		logger.Debug("ObjectType.init", "schema", t.Schema, "package", t.PackageName, "name", t.Name, "isColl", info.isCollection, "numAttrs", info.numAttributes, "info", fmt.Sprintf("%+v", info))
	}

	numAttributes := int(info.numAttributes)
	if numAttributes == 0 {
		if info.isCollection == 0 {
			if logger != nil && logger.Enabled(ctx, slog.LevelWarn) {
				logger.Warn("ObjectType.init type has no attributes", "schema", t.Schema, "package", t.PackageName, "name", t.Name, "info", fmt.Sprintf("%+v", info))
			}
		}
		t.Attributes = map[string]ObjectAttribute{}
		if cache != nil {
			cache[t.FullName()] = t
		}
		return nil
	}

	t.Attributes = make(map[string]ObjectAttribute, numAttributes)
	attrs := make([]* /*line :1163:19*/_Ctype_dpiObjectAttr /*line :1163:34*/, numAttributes)
	if func() _Ctype_int{ _cgo0 := /*line :1164:35*/d; var _cgo1 _Ctype_uint16_t = _Ctype_uint16_t /*line :1165:13*/(len(attrs)); _cgoIndex2 := &/*line :1166:39*/attrs; _cgo2 := /*line :1166:3*/(**_Ctype_dpiObjectAttr /*line :1166:21*/)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :1167:3*/_Cfunc_dpiObjectType_getAttributes(_cgo0, _cgo1, _cgo2); }() == ( /*line :1167:7*/_Ciconst_DPI_FAILURE /*line :1167:19*/) {
		return fmt.Errorf("%v.getAttributes: %w", t, t.drv.getError())
	}
	for i, attr := range attrs {
		var attrInfo  /*line :1171:16*/_Ctype_dpiObjectAttrInfo /*line :1171:35*/
		if func() _Ctype_int{ _cgo0 := /*line :1172:30*/attr; _cgoBase1 := /*line :1172:36*/&attrInfo; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1172:46*/_Cfunc_dpiObjectAttr_getInfo(_cgo0, _cgo1); }() == ( /*line :1172:50*/_Ciconst_DPI_FAILURE /*line :1172:62*/) {
			return fmt.Errorf("%v.attr_getInfo: %w", attr, t.drv.getError())
		}
		if logger != nil && logger.Enabled(ctx, slog.LevelDebug) {
			logger.Debug("getAttributes", "i", i, "attrInfo", attrInfo)
		}

		typ := attrInfo.typeInfo
		sub, err := objectTypeFromDataTypeInfo(t.drv, typ, cache)
		if err != nil {
			return err
		}
		objAttr := ObjectAttribute{
			dpiObjectAttr: attr,
			Name:          ( /*line :1186:19*/_Cfunc_GoStringN /*line :1186:29*/)(attrInfo.name,  /*line :1186:46*/_Ctype_int /*line :1186:51*/(attrInfo.nameLength)),
			ObjectType:    sub,
			Sequence:      uint32(i),
		}
		if sub.dpiObjectType != nil {
			func() _Ctype_int{ _cgo0 := /*line :1191:27*/sub.dpiObjectType; _cgoCheckPointer(_cgo0, nil); return /*line :1191:45*/_Cfunc_dpiObjectType_addRef(_cgo0); }()
		}
		//fmt.Printf("%d=%q. typ=%+v sub=%+v\n", i, objAttr.Name, typ, sub)
		t.Attributes[objAttr.Name] = objAttr
	}
	if cache != nil {
		cache[t.FullName()] = t
	}
	if closeObjectWithFinalizer && guardWithFinalizers.Load() {
		runtime.SetFinalizer(t, func(t *ObjectType) { t.Close() })
	}
	return nil
}

func (t *ObjectType) fromDataTypeInfo(typ  /*line :1205:43*/_Ctype_dpiDataTypeInfo /*line :1205:60*/, cache map[string]*ObjectType) error {
	t.dpiObjectType = typ.objectType

	t.OracleTypeNum = typ.oracleTypeNum
	t.NativeTypeNum = typ.defaultNativeTypeNum
	t.DBSize = int(typ.dbSizeInBytes)
	t.ClientSizeInBytes = int(typ.clientSizeInBytes)
	t.CharSize = int(typ.sizeInChars)
	t.Precision = int16(typ.precision)
	t.Scale = int8(typ.scale)
	t.FsPrecision = uint8(typ.fsPrecision)
	t.DomainAnnotation.init(typ)
	return t.init(cache)
}

func objectTypeFromDataTypeInfo(d *drv, typ  /*line :1220:45*/_Ctype_dpiDataTypeInfo /*line :1220:62*/, cache map[string]*ObjectType) (*ObjectType, error) {
	if d == nil {
		panic("drv is nil")
	}
	if typ.oracleTypeNum == 0 {
		panic("typ is nil")
	}
	t := &ObjectType{drv: d}
	err := t.fromDataTypeInfo(typ, cache)
	return t, err
}

// ObjectAttribute is an attribute of an Object.
type ObjectAttribute struct {
	*ObjectType
	dpiObjectAttr * /*line :1235:17*/_Ctype_dpiObjectAttr /*line :1235:32*/
	Name          string
	Sequence      uint32
}

// Close the ObjectAttribute.
func (A ObjectAttribute) Close() error {
	if A.dpiObjectAttr == nil {
		return nil
	}
	if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("ObjectAttribute.CloReplaceQuestionPlacholders()se", "name", A.Name)
	}
	if err := A.ObjectType.drv.checkExec(func()  /*line :1248:46*/_Ctype_int /*line :1248:51*/ { return func() _Ctype_int{ _cgo0 := /*line :1248:85*/A.dpiObjectAttr; _cgoCheckPointer(_cgo0, nil); return /*line :1248:101*/_Cfunc_dpiObjectAttr_release(_cgo0); }() }); err != nil {
		return err
	}
	return A.ObjectType.Close()
}

// GetObjectType returns the ObjectType for the name.
func GetObjectType(ctx context.Context, ex Execer, typeName string) (*ObjectType, error) {
	c, err := getConn(ctx, ex)
	if err != nil {
		return nil, fmt.Errorf("getConn for %s: %w", typeName, err)
	}
	return c.GetObjectType(typeName)
}

var scratch = &dataPool{Pool: sync.Pool{New: func() interface{} { return &Data{} }}}

type dataPool struct{ sync.Pool }

func (dp *dataPool) Get() *Data  { return dp.Pool.Get().(*Data) }
func (dp *dataPool) Put(d *Data) { d.reset(); dp.Pool.Put(d) }
