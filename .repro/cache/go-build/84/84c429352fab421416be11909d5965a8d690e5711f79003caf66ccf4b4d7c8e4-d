// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/mattn/go-sqlite3@v1.14.19/sqlite3_opt_serialize.go:1:1
// +build !libsqlite3 sqlite_serialize

package sqlite3

/*
#ifndef USE_LIBSQLITE3
#include <sqlite3-binding.h>
#else
#include <sqlite3.h>
#endif
#include <stdlib.h>
#include <stdint.h>
*/
import _ "unsafe"

import (
	"fmt"
	"math"
	"reflect"
	"unsafe"
)

// Serialize returns a byte slice that is a serialization of the database.
//
// See https://www.sqlite.org/c3ref/serialize.html
func (c *SQLiteConn) Serialize(schema string) ([]byte, error) {
	if schema == "" {
		schema = "main"
	}
	var zSchema * /*line :30:15*/_Ctype_char /*line :30:21*/
	zSchema = ( /*line :31:12*/_Cfunc_CString /*line :31:20*/)(schema)
	defer func() func() { _cgo0 := /*line :32:15*/unsafe.Pointer(zSchema); return func() { _cgoCheckPointer(_cgo0, nil); /*line :32:39*/_Cfunc_free(_cgo0); }}()()

	var sz  /*line :34:9*/_Ctype_sqlite3_int64 /*line :34:24*/
	ptr := func() *_Ctype_uchar{ _cgo0 := /*line :35:29*/c.db; var _cgo1 *_Ctype_char = /*line :35:35*/zSchema; var _cgo2 *_Ctype_sqlite3_int64 = /*line :35:44*/&sz; var _cgo3 _Ctype_uint = /*line :35:49*/0; _cgoCheckPointer(_cgo0, nil); return /*line :35:51*/_Cfunc_sqlite3_serialize(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ptr == nil {
		return nil, fmt.Errorf("serialize failed")
	}
	defer func() func() { _cgo0 := /*line :39:23*/unsafe.Pointer(ptr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :39:43*/_Cfunc_sqlite3_free(_cgo0); }}()()

	if sz >  /*line :41:10*/_Ctype_sqlite3_int64 /*line :41:25*/(math.MaxInt) {
		return nil, fmt.Errorf("serialized database is too large (%d bytes)", sz)
	}

	cBuf := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(ptr)),
		Len:  int(sz),
		Cap:  int(sz),
	}))

	res := make([]byte, int(sz))
	copy(res, cBuf)
	return res, nil
}

// Deserialize causes the connection to disconnect from the current database and
// then re-open as an in-memory database based on the contents of the byte slice.
//
// See https://www.sqlite.org/c3ref/deserialize.html
func (c *SQLiteConn) Deserialize(b []byte, schema string) error {
	if schema == "" {
		schema = "main"
	}
	var zSchema * /*line :64:15*/_Ctype_char /*line :64:21*/
	zSchema = ( /*line :65:12*/_Cfunc_CString /*line :65:20*/)(schema)
	defer func() func() { _cgo0 := /*line :66:15*/unsafe.Pointer(zSchema); return func() { _cgoCheckPointer(_cgo0, nil); /*line :66:39*/_Cfunc_free(_cgo0); }}()()

	tmpBuf := (* /*line :68:14*/_Ctype_uchar /*line :68:21*/)(( /*line :68:23*/_Cfunc_sqlite3_malloc64 /*line :68:40*/)( /*line :68:42*/_Ctype_sqlite3_uint64 /*line :68:58*/(len(b))))
	cBuf := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: uintptr(unsafe.Pointer(tmpBuf)),
		Len:  len(b),
		Cap:  len(b),
	}))
	copy(cBuf, b)

	rc := func() _Ctype_int{ _cgo0 := /*line :76:30*/c.db; var _cgo1 *_Ctype_char = /*line :76:36*/zSchema; var _cgo2 *_Ctype_uchar = /*line :76:45*/tmpBuf; var _cgo3 _Ctype_sqlite3_int64 = _Ctype_sqlite3_int64 /*line :76:68*/(len(b)); var _cgo4 _Ctype_sqlite3_int64 = _Ctype_sqlite3_int64 /*line :77:18*/(len(b)); var _cgo5 _Ctype_uint = /*line :77:28*/_Ciconst_SQLITE_DESERIALIZE_FREEONCLOSE /*line :77:60*/; _cgoCheckPointer(_cgo0, nil); return /*line :77:61*/_Cfunc_sqlite3_deserialize(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if rc != ( /*line :78:11*/_Ciconst_SQLITE_OK /*line :78:21*/) {
		return fmt.Errorf("deserialize failed with return %v", rc)
	}
	return nil
}
