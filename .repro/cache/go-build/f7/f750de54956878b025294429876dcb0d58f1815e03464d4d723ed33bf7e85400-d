// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/lob.go:1:1
// Copyright 2017, 2022 The Godror Authors
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package godror

/*
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"io"
	"runtime"
	"strings"
	"sync"
	"unicode/utf8"
	"unsafe"

	"github.com/godror/godror/slog"
)

// Lob is for reading/writing a LOB.
type Lob struct {
	io.Reader
	IsClob bool
}

var _ = (io.Reader)((*Lob)(nil))
var _ = (io.ReaderAt)((*Lob)(nil))

// Hijack the underlying lob reader/writer, and
// return a DirectLob for reading/writing the lob directly.
//
// After this, the Lob is unusable!
func (lob *Lob) Hijack() (*DirectLob, error) {
	if lob == nil || lob.Reader == nil {
		return nil, errors.New("lob is nil")
	}
	lr, ok := lob.Reader.(*dpiLobReader)
	if !ok {
		return nil, fmt.Errorf("Lob.Reader is %T, not *dpiLobReader", lob.Reader)
	}
	lob.Reader = nil
	return &DirectLob{drv: lr.drv, dpiLob: lr.dpiLob}, nil
}

// WriteTo writes data to w until there's no more data to write or when an error occurs.
// The return value n is the number of bytes written. Any error encountered during the write is also returned.
//
// Will use Lob.Reader.WriteTo, if Lob.Reader implements io.WriterTo.
func (lob *Lob) WriteTo(w io.Writer) (n int64, err error) {
	if wt, ok := lob.Reader.(io.WriterTo); ok {
		return wt.WriteTo(w)
	}
	return io.CopyBuffer(w, lob.Reader, make([]byte, 1<<20))
}

// NewBufferedReader returns a new bufio.Reader with the given size (or 1M if 0).
func (lob *Lob) NewBufferedReader(size int) *bufio.Reader {
	if size <= 0 {
		size = 1 << 20
	}
	return bufio.NewReaderSize(lob.Reader, size)
}

// Size exposes the underlying Reader's Size method, if it is supported.
func (lob *Lob) Size() (int64, error) {
	if lr, ok := lob.Reader.(interface{ Size() (int64, error) }); ok {
		return lr.Size()
	}
	return 0, ErrNotSupported
}

// ReadAt exposes the underlying Reader's ReadAt method, if it is supported.
func (lob *Lob) ReadAt(p []byte, off int64) (int, error) {
	if lr, ok := lob.Reader.(io.ReaderAt); ok {
		return lr.ReadAt(p, off)
	}
	return 0, ErrNotSupported
}

// Scan assigns a value from a database driver.
//
// The src value will be of one of the following types:
//
//	int64
//	float64
//	bool
//	[]byte
//	string
//	time.Time
//	nil - for NULL values
//
// An error should be returned if the value cannot be stored
// without loss of information.
func (dlr *dpiLobReader) Scan(src interface{}) error {
	b, ok := src.([]byte)
	if !ok {
		return fmt.Errorf("cannot convert LOB to %T", src)
	}
	_ = b
	return nil
}

var _ = io.ReadCloser((*dpiLobReader)(nil))
var _ = io.ReaderAt((*dpiLobReader)(nil))

type dpiLobReader struct {
	*drv
	dpiLob              * /*line :115:23*/_Ctype_dpiLob /*line :115:31*/
	buf                 []byte
	offset, sizePlusOne  /*line :117:22*/_Ctype_uint64_t /*line :117:32*/
	mu                  sync.Mutex
	chunkSize            /*line :119:22*/_Ctype_uint32_t /*line :119:32*/
	bufR, bufW          int
	finished            bool
	IsClob              bool
}

// WriteTo writes data to w until there's no more data to write or when an error occurs.
// The return value n is the number of bytes written. Any error encountered during the write is also returned.
//
// Uses efficient, multiple-of-LOB-chunk-size buffered reads.
func (dlr *dpiLobReader) WriteTo(w io.Writer) (n int64, err error) {
	size := dlr.ChunkSize()
	const minBufferSize = 1 << 20
	if size <= 0 {
		size = minBufferSize
	} else {
		for size < minBufferSize/2 { // at most 1M
			size *= 2
		}
	}
	return io.CopyBuffer(
		w,
		// Mask WriteTo method
		io.Reader(struct {
			io.Reader
		}{dlr}),
		make([]byte, size))
}

// ChunkSize returns the LOB's native chunk size. Reads/writes with a multiply of this size is the most performant.
func (dlr *dpiLobReader) ChunkSize() int {
	dlr.mu.Lock()
	defer dlr.mu.Unlock()
	if dlr.chunkSize != 0 {
		return int(dlr.chunkSize)
	}
	if err := dlr.checkExec(func()  /*line :155:33*/_Ctype_int /*line :155:38*/ {
		return func() _Ctype_int{ _cgo0 := /*line :156:32*/dlr.dpiLob; var _cgo1 *_Ctype_uint32_t = /*line :156:44*/&dlr.chunkSize; _cgoCheckPointer(_cgo0, nil); return /*line :156:59*/_Cfunc_dpiLob_getChunkSize(_cgo0, _cgo1); }()
	}); err != nil {
		dlr.chunkSize = 0
		return -1
	}
	return int(dlr.chunkSize)
}

// Read from LOB. It does buffer the reading internally against short buffers (io.ReadAll).
func (dlr *dpiLobReader) Read(p []byte) (int, error) {
	dlr.mu.Lock()
	defer dlr.mu.Unlock()
	logger := getLogger(context.TODO())
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("Read", "bufR", dlr.bufR, "bufW", dlr.bufW, "buf", cap(dlr.buf))
	}

	if dlr.buf == nil {
		if dlr.chunkSize == 0 {
			if err := dlr.checkExec(func()  /*line :175:35*/_Ctype_int /*line :175:40*/ {
				return func() _Ctype_int{ _cgo0 := /*line :176:34*/dlr.dpiLob; var _cgo1 *_Ctype_uint32_t = /*line :176:46*/&dlr.chunkSize; _cgoCheckPointer(_cgo0, nil); return /*line :176:61*/_Cfunc_dpiLob_getChunkSize(_cgo0, _cgo1); }()
			}); err != nil {
				return 0, fmt.Errorf("getChunkSize: %w", err)
			}
		}
		// If the dest buffer is big enough, avoid copying.
		if ulen :=  /*line :182:14*/_Ctype_uint64_t /*line :182:24*/(len(p)); ulen >=  /*line :182:42*/_Ctype_uint64_t /*line :182:52*/(dlr.chunkSize) || dlr.sizePlusOne != 0 && ulen+1 >= dlr.sizePlusOne {
			if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
				logger.Debug("direct read", "p", len(p), "chunkSize", dlr.chunkSize)
			}
			return dlr.read(p)
		}
		cs := int(dlr.chunkSize)
		dlr.buf = make([]byte, (maxI(len(p), 1<<20-cs)/cs+1)*cs)
		dlr.bufR, dlr.bufW = 0, 0
	} else if dlr.bufW != 0 && cap(dlr.buf) != 0 {
		var n int
		if dlr.bufR < dlr.bufW {
			n = copy(p, dlr.buf[dlr.bufR:dlr.bufW])
			dlr.bufR += n
		}
		if dlr.bufR == dlr.bufW {
			dlr.bufR, dlr.bufW = 0, 0
		}
		if n != 0 {
			return n, nil
		}
	}
	var err error
	// We only read into dlr.buf when it's empty, dlr.bufR == dlr.bufW == 0
	// nosemgrep: trailofbits.go.questionable-assignment.questionable-assignment
	dlr.bufW, err = dlr.read(dlr.buf)
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("dlr.read", "bufR", dlr.bufR, "bufW", dlr.bufW, "chunkSize", dlr.chunkSize, "error", err)
	}
	dlr.bufR = copy(p, dlr.buf[:dlr.bufW])
	if err == io.EOF && dlr.bufW != dlr.bufR {
		err = nil
	}
	return dlr.bufR, err
}

var ErrCLOB = errors.New("CLOB is not supported")

// Size returns the LOB's size. It returns ErrCLOB for CLOB,
// (works only for BLOBs), as Oracle reports CLOB size in runes, not in bytes!
func (dlr *dpiLobReader) Size() (int64, error) {
	dlr.mu.Lock()
	err := dlr.getSize()
	size := dlr.sizePlusOne - 1
	isClob := dlr.IsClob
	dlr.mu.Unlock()
	if err == nil && isClob {
		err = ErrCLOB
	}
	return int64(size), err
}
func (dlr *dpiLobReader) getSize() error {
	if dlr.sizePlusOne != 0 {
		return nil
	}
	var err error
	runtime.LockOSThread()
	if err = dlr.checkExecNoLOT(func()  /*line :239:37*/_Ctype_int /*line :239:42*/ {
		return func() _Ctype_int{ _cgo0 := /*line :240:27*/dlr.dpiLob; var _cgo1 *_Ctype_uint64_t = /*line :240:39*/&dlr.sizePlusOne; _cgoCheckPointer(_cgo0, nil); return /*line :240:56*/_Cfunc_dpiLob_getSize(_cgo0, _cgo1); }()
	}); err != nil {
		err = fmt.Errorf("getSize: %w", err)
		func() _Ctype_int{ _cgo0 := /*line :243:18*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return /*line :243:29*/_Cfunc_dpiLob_close(_cgo0); }()
		dlr.dpiLob = nil
	}
	runtime.UnlockOSThread()
	dlr.sizePlusOne++
	return err
}

// read does the real LOB reading.
func (dlr *dpiLobReader) read(p []byte) (int, error) {
	if dlr == nil {
		return 0, errors.New("read on nil dpiLobReader")
	}
	logger := getLogger(context.TODO())
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("LOB Read", "dlr", fmt.Sprintf("%p", dlr), "offset", dlr.offset, "size", dlr.sizePlusOne, "finished", dlr.finished, "clob", dlr.IsClob)
	}
	if dlr.finished || dlr.dpiLob == nil {
		return 0, io.EOF
	}
	if len(p) < 1 || dlr.IsClob && len(p) < 4 {
		return 0, io.ErrShortBuffer
	}
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	// For CLOB, sizePlusOne and offset counts the CHARACTERS!
	// See https://oracle.github.io/odpi/doc/public_functions/dpiLob.html dpiLob_readBytes
	if dlr.sizePlusOne == 0 { // first read
		// never read size before
		if err := dlr.getSize(); err != nil {
			var coder interface{ Code() int }
			if errors.As(err, &coder) && coder.Code() == 22922 || strings.Contains(err.Error(), "invalid dpiLob handle") {
				return 0, io.EOF
			}
			return 0, err
		}

		var lobType  /*line :280:15*/_Ctype_dpiOracleTypeNum /*line :280:33*/
		if err := dlr.checkExecNoLOT(func()  /*line :281:39*/_Ctype_int /*line :281:44*/ {
			return func() _Ctype_int{ _cgo0 := /*line :282:28*/dlr.dpiLob; var _cgo1 *_Ctype_dpiOracleTypeNum = /*line :282:40*/&lobType; _cgoCheckPointer(_cgo0, nil); return /*line :282:49*/_Cfunc_dpiLob_getType(_cgo0, _cgo1); }()
		}); err == nil &&
			(2017 <= lobType && lobType <= 2019) {
			dlr.IsClob = lobType == 2017 || lobType == 2018 // CLOB and NCLOB
		}
	}
	n :=  /*line :288:7*/_Ctype_uint64_t /*line :288:17*/(len(p))
	amount := n
	if dlr.IsClob {
		amount /= 4 // dpiLob_readBytes' amount is the number of CHARACTERS for CLOBs.
	}
	// fmt.Printf("%p.Read offset=%d sizePlusOne=%d n=%d\n", dlr.dpiLob, dlr.offset, dlr.sizePlusOne, n)
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("Read", "offset", dlr.offset, "sizePlusOne", dlr.sizePlusOne, "n", n, "amount", amount)
	}
	if !dlr.IsClob && dlr.offset+1 >= dlr.sizePlusOne {
		if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("LOB reached end", "offset", dlr.offset, "size", dlr.sizePlusOne)
		}
		return 0, io.EOF
	}
	if err := dlr.drv.checkExecNoLOT(func()  /*line :303:42*/_Ctype_int /*line :303:47*/ {
		return func() _Ctype_int{ _cgo0 := /*line :304:29*/dlr.dpiLob; var _cgo1 _Ctype_uint64_t = /*line :304:41*/dlr.offset + 1; var _cgo2 _Ctype_uint64_t = /*line :304:55*/amount; var _cgo3 *_Ctype_char = /*line :304:63*/(*_Ctype_char /*line :304:71*/)(unsafe.Pointer(&p[0])); var _cgo4 *_Ctype_uint64_t = /*line :304:97*/&n; _cgoCheckPointer(_cgo0, nil); return /*line :304:100*/_Cfunc_dpiLob_readBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}); err != nil {
		if logger != nil {
			logger.Error("readBytes", "error", err)
		}
		func() _Ctype_int{ _cgo0 := /*line :309:18*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return /*line :309:29*/_Cfunc_dpiLob_close(_cgo0); }()
		dlr.dpiLob = nil
		var codeErr interface{ Code() int }
		if dlr.finished = errors.As(err, &codeErr) && codeErr.Code() == 1403; dlr.finished {
			dlr.offset += n
			return int(n), io.EOF
		}
		return int(n), fmt.Errorf("dpiLob_readbytes(lob=%p offset=%d n=%d): %w", dlr.dpiLob, dlr.offset, len(p), err)
	}
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("read", "n", n)
	}
	if dlr.IsClob {
		dlr.offset +=  /*line :322:17*/_Ctype_uint64_t /*line :322:27*/(utf8.RuneCount(p[:n]))
	} else {
		dlr.offset += n
	}
	var err error
	if amount != 0 && n == 0 || !dlr.IsClob && dlr.offset+1 >= dlr.sizePlusOne {
		func() _Ctype_int{ _cgo0 := /*line :328:18*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return /*line :328:29*/_Cfunc_dpiLob_close(_cgo0); }()
		dlr.dpiLob = nil
		dlr.finished = true
		err = io.EOF
	}
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("LOB", "n", n, "offset", dlr.offset, "size", dlr.sizePlusOne, "finished", dlr.finished, "clob", dlr.IsClob, "error", err)
	}
	return int(n), err
}

// ReadAt reads at the specified offset (in bytes).
// Works only for BLOBs!
func (dlr *dpiLobReader) ReadAt(p []byte, off int64) (int, error) {
	dlr.mu.Lock()
	defer dlr.mu.Unlock()
	if dlr.IsClob {
		return 0, ErrCLOB
	}
	n :=  /*line :347:7*/_Ctype_uint64_t /*line :347:17*/(len(p))
	err := dlr.checkExec(func()  /*line :348:30*/_Ctype_int /*line :348:35*/ {
		return func() _Ctype_int{ _cgo0 := /*line :349:29*/dlr.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :349:51*/(off + 1); var _cgo2 _Ctype_uint64_t = /*line :349:60*/n; var _cgo3 *_Ctype_char = /*line :349:63*/(*_Ctype_char /*line :349:71*/)(unsafe.Pointer(&p[0])); var _cgo4 *_Ctype_uint64_t = /*line :349:97*/&n; _cgoCheckPointer(_cgo0, nil); return /*line :349:100*/_Cfunc_dpiLob_readBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	})
	if err != nil {
		err = fmt.Errorf("readBytes at %d for %d: %w", off, n, dlr.getError())
	}
	return int(n), err
}
func (dlr *dpiLobReader) Close() error {
	if dlr == nil || dlr.dpiLob == nil {
		return nil
	}
	lob := dlr.dpiLob
	dlr.dpiLob = nil
	return closeLob(dlr, lob)
}

type dpiLobWriter struct {
	*drv
	dpiLob * /*line :367:10*/_Ctype_dpiLob /*line :367:18*/
	offset  /*line :368:9*/_Ctype_uint64_t /*line :368:19*/
	opened bool
	isClob bool
}

func (dlw *dpiLobWriter) Write(p []byte) (int, error) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	lob := dlw.dpiLob
	if !dlw.opened {
		// fmt.Printf("open %p\n", lob)
		if err := dlw.drv.checkExecNoLOT(func()  /*line :380:43*/_Ctype_int /*line :380:48*/ {
			return func() _Ctype_int{ _cgo0 := /*line :381:33*/lob; _cgoCheckPointer(_cgo0, nil); return /*line :381:37*/_Cfunc_dpiLob_openResource(_cgo0); }()
		}); err != nil {
			return 0, fmt.Errorf("openResources(%p): %w", lob, err)
		}
		dlw.opened = true
	}

	n :=  /*line :388:7*/_Ctype_uint64_t /*line :388:17*/(len(p))
	if err := dlw.drv.checkExecNoLOT(func()  /*line :389:42*/_Ctype_int /*line :389:47*/ {
		return func() _Ctype_int{ _cgo0 := /*line :390:30*/lob; var _cgo1 _Ctype_uint64_t = /*line :390:35*/dlw.offset + 1; var _cgo2 *_Ctype_char = /*line :390:49*/(*_Ctype_char /*line :390:57*/)(unsafe.Pointer(&p[0])); var _cgo3 _Ctype_uint64_t = /*line :390:83*/n; _cgoCheckPointer(_cgo0, nil); return /*line :390:85*/_Cfunc_dpiLob_writeBytes(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		err = fmt.Errorf("writeBytes(%p, offset=%d, data=%d): %w", lob, dlw.offset, n, err)
		dlw.dpiLob = nil
		_ = closeLob(dlw, lob)
		return 0, err
	}
	// fmt.Printf("written %q into %p@%d\n", p[:n], lob, dlw.offset)
	dlw.offset += n

	return int(n), nil
}

func (dlw *dpiLobWriter) Close() error {
	if dlw == nil || dlw.dpiLob == nil {
		return nil
	}
	lob := dlw.dpiLob
	dlw.dpiLob = nil
	return closeLob(dlw, lob)
}

func closeLob(d interface{ getError() error }, lob * /*line :412:53*/_Ctype_dpiLob /*line :412:61*/) error {
	if lob == nil {
		return nil
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var isOpen  /*line :420:13*/_Ctype_int /*line :420:18*/
	if func() _Ctype_int{ _cgo0 := /*line :421:32*/lob; var _cgo1 *_Ctype_int = /*line :421:37*/&isOpen; _cgoCheckPointer(_cgo0, nil); return /*line :421:45*/_Cfunc_dpiLob_getIsResourceOpen(_cgo0, _cgo1); }() != ( /*line :421:49*/_Ciconst_DPI_FAILURE /*line :421:61*/) && isOpen == 1 {
		if func() _Ctype_int{ _cgo0 := /*line :422:29*/lob; _cgoCheckPointer(_cgo0, nil); return /*line :422:33*/_Cfunc_dpiLob_closeResource(_cgo0); }() == ( /*line :422:37*/_Ciconst_DPI_FAILURE /*line :422:49*/) {
			if err := d.getError(); err != nil {
				var codeErr interface{ Code() int }
				if errors.As(err, &codeErr) && codeErr.Code() != 22289 { // cannot perform %s operation on an unopened file or LOB
					return fmt.Errorf("closeResource(%p): %w", lob, err)
				}
			}
		}
	}
	func() _Ctype_int{ _cgo0 := /*line :431:19*/lob; _cgoCheckPointer(_cgo0, nil); return /*line :431:23*/_Cfunc_dpiLob_release(_cgo0); }()
	return nil
}

// DirectLob holds a Lob and allows direct (Read/WriteAt, not streaming Read/Write) operations on it.
type DirectLob struct {
	drv            *drv
	dpiLob         * /*line :438:18*/_Ctype_dpiLob /*line :438:26*/
	opened, isClob bool
}

var _ = io.ReaderAt((*DirectLob)(nil))
var _ = io.WriterAt((*DirectLob)(nil))

// NewTempLob returns a temporary LOB as DirectLob.
func (c *conn) NewTempLob(isClob bool) (*DirectLob, error) {
	typ :=  /*line :447:9*/_Ctype_uint /*line :447:15*/(( /*line :447:16*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :447:37*/))
	if isClob {
		typ = ( /*line :449:9*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :449:30*/)
	}
	lob := DirectLob{drv: c.drv, isClob: isClob}
	if err := c.checkExec(func()  /*line :452:31*/_Ctype_int /*line :452:36*/ { return func() _Ctype_int{ _cgo0 := /*line :452:67*/c.dpiConn; var _cgo1 _Ctype_dpiOracleTypeNum = /*line :452:78*/typ; _cgoBase2 := /*line :452:83*/&lob.dpiLob; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :452:95*/_Cfunc_dpiConn_newTempLob(_cgo0, _cgo1, _cgo2); }() }); err != nil {
		return nil, fmt.Errorf("newTempLob: %w", err)
	}
	return &lob, nil
}

// Close the Lob.
func (dl *DirectLob) Close() error {
	if !dl.opened {
		return nil
	}
	lob := dl.dpiLob
	dl.opened, dl.dpiLob = false, nil
	return closeLob(dl.drv, lob)
}

// Size returns the size of the LOB.
//
// WARNING: for historical reasons, Oracle stores CLOBs and NCLOBs using the UTF-16 encoding,
// regardless of what encoding is otherwise in use by the database.
// The number of characters, however, is defined by the number of UCS-2 codepoints.
// For this reason, if a character requires more than one UCS-2 codepoint,
// the size returned will be inaccurate and care must be taken to account for the difference!
func (dl *DirectLob) Size() (int64, error) {
	var n  /*line :476:8*/_Ctype_uint64_t /*line :476:18*/
	if dl.dpiLob == nil {
		return 0, nil
	}
	if err := dl.drv.checkExec(func()  /*line :480:36*/_Ctype_int /*line :480:41*/ {
		return func() _Ctype_int{ _cgo0 := /*line :481:27*/dl.dpiLob; var _cgo1 *_Ctype_uint64_t = /*line :481:38*/&n; _cgoCheckPointer(_cgo0, nil); return /*line :481:41*/_Cfunc_dpiLob_getSize(_cgo0, _cgo1); }()
	}); err != nil {
		var coder interface{ Code() int }
		if errors.As(err, &coder) && coder.Code() == 22922 || strings.Contains(err.Error(), "invalid dpiLob handle") {
			return 0, nil
		}
		return int64(n), fmt.Errorf("getSize: %w", err)
	}
	return int64(n), nil
}

// Trim the LOB to the given size.
func (dl *DirectLob) Trim(size int64) error {
	if err := dl.drv.checkExec(func()  /*line :494:36*/_Ctype_int /*line :494:41*/ {
		return func() _Ctype_int{ _cgo0 := /*line :495:24*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :495:45*/(size); _cgoCheckPointer(_cgo0, nil); return /*line :495:52*/_Cfunc_dpiLob_trim(_cgo0, _cgo1); }()
	}); err != nil {
		return fmt.Errorf("trim: %w", err)
	}
	return nil
}

// Set the contents of the LOB to the given byte slice.
// The LOB is cleared first.
func (dl *DirectLob) Set(p []byte) error {
	if err := dl.drv.checkExec(func()  /*line :505:36*/_Ctype_int /*line :505:41*/ {
		return func() _Ctype_int{ _cgo0 := /*line :506:32*/dl.dpiLob; var _cgo1 *_Ctype_char = /*line :506:43*/(*_Ctype_char /*line :506:51*/)(unsafe.Pointer(&p[0])); var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :506:87*/(len(p)); _cgoCheckPointer(_cgo0, nil); return /*line :506:96*/_Cfunc_dpiLob_setFromBytes(_cgo0, _cgo1, _cgo2); }()
	}); err != nil {
		return fmt.Errorf("setFromBytes: %w", err)
	}
	return nil
}

// ReadAt reads at most len(p) bytes into p at offset.
//
// CLOB's offset must be in amount of characters, and does not work reliably!
//
// WARNING: for historical reasons, Oracle stores CLOBs and NCLOBs using the UTF-16 encoding,
// regardless of what encoding is otherwise in use by the database.
// The number of characters, however, is defined by the number of UCS-2 codepoints.
// For this reason, if a character requires more than one UCS-2 codepoint,
// the size returned will be inaccurate and care must be taken to account for the difference!
func (dl *DirectLob) ReadAt(p []byte, offset int64) (int, error) {
	n :=  /*line :523:7*/_Ctype_uint64_t /*line :523:17*/(len(p))
	if dl.dpiLob == nil {
		return 0, io.EOF
	}
	amount := n
	if dl.isClob {
		amount /= 4
		if amount == 0 {
			return 0, io.ErrShortBuffer
		}
	}
	if err := dl.drv.checkExec(func()  /*line :534:36*/_Ctype_int /*line :534:41*/ {
		return func() _Ctype_int{ _cgo0 := /*line :535:29*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :535:50*/(offset) + 1; var _cgo2 _Ctype_uint64_t = /*line :535:62*/n; var _cgo3 *_Ctype_char = /*line :535:65*/(*_Ctype_char /*line :535:73*/)(unsafe.Pointer(&p[0])); var _cgo4 *_Ctype_uint64_t = /*line :535:99*/&n; _cgoCheckPointer(_cgo0, nil); return /*line :535:102*/_Cfunc_dpiLob_readBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}); err != nil {
		return int(n), fmt.Errorf("readBytes: %w", err)
	}
	return int(n), nil
}

// WriteAt writes p starting at offset.
func (dl *DirectLob) WriteAt(p []byte, offset int64) (int, error) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	if !dl.opened {
		// fmt.Printf("open %p\n", lob)
		if err := dl.drv.checkExecNoLOT(func()  /*line :549:42*/_Ctype_int /*line :549:47*/ {
			return func() _Ctype_int{ _cgo0 := /*line :550:33*/dl.dpiLob; _cgoCheckPointer(_cgo0, nil); return /*line :550:43*/_Cfunc_dpiLob_openResource(_cgo0); }()
		}); err != nil {
			return 0, fmt.Errorf("openResources(%p): %w", dl.dpiLob, err)
		}
		dl.opened = true
	}

	n :=  /*line :557:7*/_Ctype_uint64_t /*line :557:17*/(len(p))
	if err := dl.drv.checkExecNoLOT(func()  /*line :558:41*/_Ctype_int /*line :558:46*/ {
		return func() _Ctype_int{ _cgo0 := /*line :559:30*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :559:51*/(offset) + 1; var _cgo2 *_Ctype_char = /*line :559:63*/(*_Ctype_char /*line :559:71*/)(unsafe.Pointer(&p[0])); var _cgo3 _Ctype_uint64_t = /*line :559:97*/n; _cgoCheckPointer(_cgo0, nil); return /*line :559:99*/_Cfunc_dpiLob_writeBytes(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}); err != nil {
		return int(n), fmt.Errorf("writeBytes: %w", err)
	}
	return int(n), nil
}

// GetFileName Return directory alias and file name for a BFILE type LOB.
func (dl *DirectLob) GetFileName() (dir, file string, err error) {
	var directoryAliasLength, fileNameLength  /*line :568:43*/_Ctype_uint32_t /*line :568:53*/
	var directoryAlias, fileName * /*line :569:32*/_Ctype_char /*line :569:38*/
	if err := dl.drv.checkExec(func()  /*line :570:36*/_Ctype_int /*line :570:41*/ {
		return func() _Ctype_int{ _cgo0 := /*line :571:43*/dl.dpiLob; _cgoBase1 := /*line :572:4*/&directoryAlias; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :573:4*/&directoryAliasLength; _cgoBase3 := /*line :574:4*/&fileName; _cgo3 := _cgoBase3; var _cgo4 *_Ctype_uint32_t = /*line :575:4*/&fileNameLength; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :576:4*/_Cfunc_dpiLob_getDirectoryAndFileName(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}); err != nil {
		return dir, file, fmt.Errorf("GetFileName: %w", err)
	}
	dir = ( /*line :580:8*/_Cfunc_GoStringN /*line :580:18*/)(directoryAlias,  /*line :580:36*/_Ctype_int /*line :580:41*/(directoryAliasLength))
	file = ( /*line :581:9*/_Cfunc_GoStringN /*line :581:19*/)(fileName,  /*line :581:31*/_Ctype_int /*line :581:36*/(fileNameLength))
	return dir, file, nil
}

func maxI(a, b int) int {
	if a < b {
		return b
	}
	return a
}
