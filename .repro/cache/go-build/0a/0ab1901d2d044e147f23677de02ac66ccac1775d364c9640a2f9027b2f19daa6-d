// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/json.go:1:1
package godror

/*
#include <stdlib.h>
#include "dpiImpl.h"

// All CGO functions are used because handling unions, indexing,
// nested callocs for substructures is hard to handle in Go code

void godror_allocate_dpiNode(dpiJsonNode **dpijsonnode) {
	*dpijsonnode = (dpiJsonNode *)(calloc(1, sizeof(dpiJsonNode)));
	dpiDataBuffer *dpijsonDataBuffer = (dpiDataBuffer *)(calloc(1, sizeof(dpiDataBuffer)));
	(*dpijsonnode)->value = dpijsonDataBuffer;
}

void godror_free_dpiNode(dpiJsonNode *node) {
    if(node == NULL) {
        return;
    }
    if (node->value) {
        free(node->value);
        node->value = NULL;
    }
    free(node);
    node = NULL;
}

void godror_setObjectFields(dpiJsonObject * jsonobj, int i, dpiJsonNode **jnode)
{
    *jnode = &(jsonobj->fields[i]);
    jsonobj->fields[i].value = &jsonobj->fieldValues[i];
}

void godror_dpiJsonObject_setKey(dpiJsonNode *dpijsonnode, int index, const char *key, uint32_t keyLength) {
    dpiJsonObject *dpijsonobj = &(dpijsonnode->value->asJsonObject);
    dpijsonobj->fieldNames[index] = calloc((keyLength + 1), sizeof(char));
    memcpy(dpijsonobj->fieldNames[index], key, keyLength);
    dpijsonobj->fieldNames[index][keyLength] = '\0';
    dpijsonobj->fieldNameLengths[index] = keyLength;
}

void godror_dpiasJsonObject(dpiJsonNode *dpijsonnode, dpiJsonObject **dpijsonobj)
{
    *dpijsonobj = &(dpijsonnode->value->asJsonObject);
}

void godror_dpiasJsonArray(dpiJsonNode *dpijsonnode, dpiJsonArray **dpijsonobj)
{
    *dpijsonobj = &(dpijsonnode->value->asJsonArray);
}

void godror_setArrayElements(dpiJsonArray * jsonarr, int i, dpiJsonNode **jnode)
{
    *jnode = &(jsonarr->elements[i]);
    jsonarr->elements[i].value = &jsonarr->elementValues[i];
}

void godror_dpiJson_setDouble(dpiJsonNode *topNode, double value) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
    topNode->value->asDouble = value;
}

void godror_dpiJson_setInt64(dpiJsonNode *topNode, int64_t value) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_INT64;
    topNode->value->asInt64 = value;
}

void godror_dpiJson_setUint64(dpiJsonNode *topNode, uint64_t value) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_UINT64;
    topNode->value->asUint64 = value;
}

void godror_dpiJson_setTime(dpiJsonNode *topNode, dpiData *data) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_TIMESTAMP;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_TIMESTAMP;
    topNode->value->asTimestamp = data->value.asTimestamp;
}

void godror_dpiJson_setBytes(dpiJsonNode *topNode, dpiData *data) {
    uint32_t size = data->value.asBytes.length;
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_RAW;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
    topNode->value->asBytes.ptr = calloc(1, size);
    memcpy(topNode->value->asBytes.ptr, data->value.asBytes.ptr, size);
    topNode->value->asBytes.length = size;
}

void godror_dpiJson_setNumber(dpiJsonNode *topNode, const _GoString_ value) {
    uint32_t length;
    length = _GoStringLen(value);
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
    topNode->value->asBytes.ptr = calloc(1, length);
    memcpy(topNode->value->asBytes.ptr, _GoStringPtr(value), length);
    topNode->value->asBytes.length = length;
}

void godror_dpiJson_setIntervalDS(dpiJsonNode *topNode, dpiData *data) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_DS;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_INTERVAL_DS;
    topNode->value->asIntervalDS = data->value.asIntervalDS;
}

void godror_dpiJson_setBool(dpiJsonNode *topNode, dpiData *data) {
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_BOOLEAN;
    topNode->value->asBoolean = data->value.asBoolean;
}

void godror_dpiJson_setString(dpiJsonNode *topNode, dpiData *data) {
    uint32_t size = data->value.asBytes.length;
    topNode->oracleTypeNum = DPI_ORACLE_TYPE_VARCHAR;
    topNode->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
    // make a copy before passing to C?
    topNode->value->asBytes.ptr = calloc(1, size);
    memcpy(topNode->value->asBytes.ptr, data->value.asBytes.ptr, size);
    topNode->value->asBytes.length = size;
}

void godror_dpiJsonObject_initialize(dpiJsonNode **dpijsonnode, uint32_t numfields) {
    dpiJsonObject dpijsonobjtmp;
    dpiJsonObject *dpijsonobj = &dpijsonobjtmp;
    (*dpijsonnode)->oracleTypeNum = DPI_ORACLE_TYPE_JSON_OBJECT;
    (*dpijsonnode)->nativeTypeNum = DPI_NATIVE_TYPE_JSON_OBJECT;
    dpijsonobj->fieldNames = (calloc(numfields,  sizeof(char *)));
    dpijsonobj->fields = (dpiJsonNode *)(calloc(numfields, sizeof(dpiJsonNode)));
    dpijsonobj->fieldNameLengths = calloc(numfields, sizeof(uint32_t));
    dpijsonobj->fieldValues = (dpiDataBuffer *)calloc(numfields, sizeof(dpiDataBuffer));
	dpijsonobj->numFields = numfields;
    (*dpijsonnode)->value->asJsonObject = *dpijsonobj;
}

void godror_dpiJsonArray_initialize(dpiJsonNode **dpijsonnode, uint32_t numelem) {
    dpiJsonArray dpijsonarrtmp;
    dpiJsonArray *dpijsonarr = &dpijsonarrtmp;
    (*dpijsonnode)->oracleTypeNum = DPI_ORACLE_TYPE_JSON_ARRAY;
    (*dpijsonnode)->nativeTypeNum = DPI_NATIVE_TYPE_JSON_ARRAY;
    dpijsonarr->elements = calloc(numelem, sizeof(dpiJsonNode));
    dpijsonarr->elementValues = (dpiDataBuffer *)calloc(numelem, sizeof(dpiDataBuffer));
	dpijsonarr->numElements = numelem;
    (*dpijsonnode)->value->asJsonArray = *dpijsonarr;
}

void godror_dpiJsonNodeFree(dpiJsonNode *node)
{
    dpiJsonArray *array;
    dpiJsonObject *obj;
    uint32_t i;

    if (node == NULL)
    {
        return;
    }

    switch (node->nativeTypeNum) {
        case DPI_NATIVE_TYPE_BYTES:
            if(node->value->asBytes.ptr) {
                free(node->value->asBytes.ptr);
                node->value->asBytes.ptr = NULL;
            }
            break;
        case DPI_NATIVE_TYPE_JSON_ARRAY:
            array = &node->value->asJsonArray;
            if (array->elements) {
                for (i = 0; i < array->numElements; i++) {
                    if (array->elements[i].value) {
                        godror_dpiJsonNodeFree(&array->elements[i]);
                    }
                }
                free(array->elements);
                array->elements = NULL;
            }
            if (array->elementValues) {
                free(array->elementValues);
                array->elementValues = NULL;
            }
            break;
        case DPI_NATIVE_TYPE_JSON_OBJECT:
            obj = &node->value->asJsonObject;
            if (obj->fields) {
                for (i = 0; i < obj->numFields; i++) {
                    if (obj->fields[i].value)
                        godror_dpiJsonNodeFree(&obj->fields[i]);
                }
                free(obj->fields);
                obj->fields = NULL;
            }
            if (obj->fieldNames) {
                for (i = 0; i < obj->numFields; i++) {
                    if (obj->fieldNames[i]) {
                        free(obj->fieldNames[i]);
                        obj->fieldNames[i] = NULL;
                    }
                }
                free(obj->fieldNames);
                obj->fieldNames = NULL;
            }
            if (obj->fieldNameLengths) {
                free(obj->fieldNameLengths);
                obj->fieldNameLengths = NULL;
            }
            if (obj->fieldValues) {
                free(obj->fieldValues);
                obj->fieldValues = NULL;
            }
            break;
    }
}

void godror_dpiJsonfreeMem(dpiJsonNode *node) {
    if (node == NULL)
    {
        return;
    }
    godror_dpiJsonNodeFree(node);
    godror_free_dpiNode(node);
}

*/
import _ "unsafe"

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"
	"unsafe"
)

// JSONOption provides an option to retrieve scalar values
// from JSON tree.
//
// DPI_JSON_OPT_NUMBER_AS_STRING - returns value stored as NUMBER in DB
// as godror.Number.
// DPI_JSON_OPT_DEAFULT - returns value stored as NUMBER in DB as float64.
type JSONOption uint8

var ErrInvalidJSON = errors.New("invalid JSON Document")
var ErrInvalidType = errors.New("invalid JSON Scalar Type")

const (
	JSONOptDefault        = JSONOption(( /*line :247:37*/_Ciconst_DPI_JSON_OPT_DEFAULT /*line :247:58*/))
	JSONOptNumberAsString = JSONOption(( /*line :248:37*/_Ciconst_DPI_JSON_OPT_NUMBER_AS_STRING /*line :248:67*/))
)

// JSON holds the JSON data to/from Oracle.
// It is like a root node in JSON tree.
type JSON struct {
	dpiJson * /*line :254:11*/_Ctype_dpiJson /*line :254:20*/
}

// Get retrieves the data stored in JSON based on option, opts.
func (j JSON) Get(data *Data, opts JSONOption) error {
	var node * /*line :259:12*/_Ctype_dpiJsonNode /*line :259:25*/
	if func() _Ctype_int{ _cgo0 := /*line :260:24*/j.dpiJson; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :260:45*/(opts); _cgoBase2 := /*line :260:86*/&node; _cgo2 := /*line :260:53*/(**_Ctype_dpiJsonNode /*line :260:69*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :260:94*/_Cfunc_dpiJson_getValue(_cgo0, _cgo1, _cgo2); }() == ( /*line :260:98*/_Ciconst_DPI_FAILURE /*line :260:110*/) {
		return ErrInvalidJSON
	}
	jsonNodeToData(data, node)
	return nil
}

// GetJSONObject retrieves JSONObject from JSON based on option, opts.
// It returns error if JSON doesnt represent object type.
func (j JSON) GetJSONObject(opts JSONOption) (JSONObject, error) {
	var node * /*line :270:12*/_Ctype_dpiJsonNode /*line :270:25*/
	var d Data
	if func() _Ctype_int{ _cgo0 := /*line :272:24*/j.dpiJson; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :272:45*/(opts); _cgoBase2 := /*line :272:86*/&node; _cgo2 := /*line :272:53*/(**_Ctype_dpiJsonNode /*line :272:69*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :272:94*/_Cfunc_dpiJson_getValue(_cgo0, _cgo1, _cgo2); }() == ( /*line :272:98*/_Ciconst_DPI_FAILURE /*line :272:110*/) {
		return JSONObject{}, ErrInvalidJSON
	}
	jsonNodeToData(&d, node)
	if  /*line :276:5*/_Ctype_dpiOracleTypeNum /*line :276:23*/(node.oracleTypeNum) != ( /*line :276:47*/_Ciconst_DPI_ORACLE_TYPE_JSON_OBJECT /*line :276:75*/) {
		return JSONObject{}, ErrInvalidType
	}
	return JSONObject{dpiJsonObject: ( /*line :279:35*/_Cfunc_dpiData_getJsonObject /*line :279:57*/)(&(d.dpiData))}, nil
}

// GetJSONArray retrieves JSONArray from JSON based on option, opts.
// It returns error if JSON doesnt represent array type.
func (j JSON) GetJSONArray(opts JSONOption) (JSONArray, error) {
	var node * /*line :285:12*/_Ctype_dpiJsonNode /*line :285:25*/
	if func() _Ctype_int{ _cgo0 := /*line :286:24*/j.dpiJson; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :286:45*/(opts); _cgoBase2 := /*line :286:86*/&node; _cgo2 := /*line :286:53*/(**_Ctype_dpiJsonNode /*line :286:69*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :286:94*/_Cfunc_dpiJson_getValue(_cgo0, _cgo1, _cgo2); }() == ( /*line :286:98*/_Ciconst_DPI_FAILURE /*line :286:110*/) {
		return JSONArray{}, ErrInvalidJSON
	}
	var d Data
	jsonNodeToData(&d, node)
	if  /*line :291:5*/_Ctype_dpiOracleTypeNum /*line :291:23*/(node.oracleTypeNum) != ( /*line :291:47*/_Ciconst_DPI_ORACLE_TYPE_JSON_ARRAY /*line :291:74*/) {
		return JSONArray{}, ErrInvalidType
	}
	return JSONArray{dpiJsonArray: ( /*line :294:33*/_Cfunc_dpiData_getJsonArray /*line :294:54*/)(&(d.dpiData))}, nil
}

// GetJSONScalar retrieves JSONScalar from JSON based on option, opts.
func (j JSON) GetJSONScalar(opts JSONOption) (JSONScalar, error) {
	var node * /*line :299:12*/_Ctype_dpiJsonNode /*line :299:25*/
	if func() _Ctype_int{ _cgo0 := /*line :300:24*/j.dpiJson; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :300:45*/(opts); _cgoBase2 := /*line :300:86*/&node; _cgo2 := /*line :300:53*/(**_Ctype_dpiJsonNode /*line :300:69*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :300:94*/_Cfunc_dpiJson_getValue(_cgo0, _cgo1, _cgo2); }() == ( /*line :300:98*/_Ciconst_DPI_FAILURE /*line :300:110*/) {
		return JSONScalar{}, ErrInvalidJSON
	}
	return JSONScalar{dpiJsonNode: node}, nil
}

// GetValue converts the native DB type stored in JSON into an interface value.
// The scalar values stored in JSON get converted as below.
//
//	map[string]interface{}, for JSON object type
//	[]interface{}, for JSON arrays
//	godror.Number or float64 based on options for NUMBER
//	bool , for boolean
//	byte[], for RAW
//	time.Duration, for INTERVAL DAY TO SECOND
//	time.Time, for TIMESTAMP
//	string, for VARCHAR2(string)
func (j JSON) GetValue(opts JSONOption) (interface{}, error) {
	jScalar, err := j.GetJSONScalar(opts)
	if err != nil {
		// later
	} else if val, err2 := jScalar.GetValue(); err2 != nil {
		err = err2
	} else {
		return val, nil
	}
	if logger := getLogger(context.TODO()); logger != nil {
		logger.Error("JSON.GetValue", "error", err)
	}
	return nil, err
}

// String returns standard JSON formatted string
func (j JSON) String() string {
	// json library is used, it will be removed
	// with direct call to get JSON string from JSON.
	// Returning empty string for error case, fix?

	jScalar, err := j.GetJSONScalar(JSONOptNumberAsString)
	if err != nil {
		// later
	} else if jScalarVal, err2 := jScalar.GetValue(); err2 != nil {
		err = err2
	} else if data, err2 := json.Marshal(jScalarVal); err2 != nil {
		err = err2
	} else {
		return string(data)
	}
	if logger := getLogger(context.TODO()); logger != nil {
		logger.Error("JSON.String", "error", err)
	}
	return ""
}

// jsonNodeToData gets the data from dpiJsonNode
func jsonNodeToData(data *Data, node * /*line :355:39*/_Ctype_dpiJsonNode /*line :355:52*/) {
	if node.value == nil {
		data.dpiData.isNull = 1
		return
	}
	data.dpiData.value = *node.value
	data.NativeTypeNum = node.nativeTypeNum
}

// JSONStringFlags represents the input JSON string format.
// It can be standard JSON format or it can include ORACLE extended types,
// BSON extended types.
type JSONStringFlags uint

// JSONString encapsulates JSON formatted string.
type JSONString struct {
	Flags JSONStringFlags // standard , extended types for OSON, BSON
	Value string          // JSON input
}

// JSONValue indicates the input bind value provided for DB column type JSON.
// Valid inputs: int, int8, int16, int32, int64, uint, uint8, uint16,
// uint32, uint64, float32, float64, string, map, array, string and bool.
//
// for  int, int8, int16, int32, int64, uint, uint8, uint16, uint32,
//      uint64, float32, float64; DB native type NUMBER is used.
// for  string; DB native type VARCHAR2 is used.
// for  time.Time; DB native type TIMESTAMP is used.
// for  time.Duration; DB native type INTERVAL DAY TO SECOND is used.
// for  []byte; DB native type RAW is used.
// for  bool; DB native type boolean is used.
// for  map[string]interface{}; DB type JSON Object is used.
// for  []interface{}; DB native type JSON Array is used.

type JSONValue struct {
	Value interface{}
}

// JSONScalar holds the JSON data to/from Oracle.
// It includes all scalar values such as int, int8, int16, int32, int64,
// uint, uint8, uint16, uint32, uint64, float32, float64, string,
// map, array, string, byte[], time.Time, time.Duration, godror.Number and bool.
type JSONScalar struct {
	dpiJsonNode * /*line :398:15*/_Ctype_dpiJsonNode /*line :398:28*/
}

// GetValue converts native DB type stored in JSONScalar to an interface value.
// The scalar value stored in JSONScalar gets converted as below.
//
//	map[string]interface{}, for JSON object type
//	[]interface{}, for JSON arrays
//	godror.Number or float64 based on options for NUMBER
//	bool , for JSON boolean
//	byte[], for JSON RAW
//	time.Duration, for INTERVAL DAY TO SECOND
//	time.Time, for TIMESTAMP
//	string, for VARCHAR2(string)
func (j JSONScalar) GetValue() (val interface{}, err error) {
	var d Data
	jsonNodeToData(&d, j.dpiJsonNode)
	if j.dpiJsonNode.oracleTypeNum == ( /*line :415:36*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :415:59*/) {
		val = getJSONScalarNumber(d)
	} else if j.dpiJsonNode.oracleTypeNum == ( /*line :417:43*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :417:67*/) {
		val, err = getJSONScalarString(d)
	} else {
		val = d.Get()
		if j.dpiJsonNode.oracleTypeNum == ( /*line :421:37*/_Ciconst_DPI_ORACLE_TYPE_JSON_OBJECT /*line :421:65*/) {
			jobj := val.(JSONObject)
			val, err = jobj.GetValue()
		} else if j.dpiJsonNode.oracleTypeNum == ( /*line :424:44*/_Ciconst_DPI_ORACLE_TYPE_JSON_ARRAY /*line :424:71*/) {
			jarr := val.(JSONArray)
			val, err = jarr.GetValue()
		} else {
			err = nil
		}
	}
	return
}

// getJSONScalarNumber returns DB NUMBER as godror.Number for option,
// JSONOptNumberAsString and float64 for option, JSONOptDefault.
func getJSONScalarNumber(d Data) (val interface{}) {
	b := d.Get()
	if d.NativeTypeNum == ( /*line :438:24*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :438:46*/) {
		val = Number(b.([]byte))
	} else {
		val = b.(float64)
	}
	return
}

// getJSONScalarString converts the byte array of VARCHAR2 to string
func getJSONScalarString(d Data) (string, error) {
	b := d.Get()
	return string(b.([]byte)), nil
}

// JSONArray represents the array input.
type JSONArray struct {
	dpiJsonArray * /*line :454:16*/_Ctype_dpiJsonArray /*line :454:30*/
}

// Len returns the number of elements in the JSONArray.
func (j JSONArray) Len() int { return int(j.dpiJsonArray.numElements) }

// GetElement returns the ith element in JSONArray as data.
func (j JSONArray) GetElement(i int) Data {
	elts := jsonArraySlice(j.dpiJsonArray)
	var d Data
	jsonNodeToData(&d, &elts[i])
	return d

}

// Get returns the data array from JSONArray
func (j JSONArray) Get(nodes []Data) []Data {
	elts := jsonArraySlice(j.dpiJsonArray)
	for i := range elts {
		var d Data
		jsonNodeToData(&d, &elts[i])
		nodes = append(nodes, d)
	}
	return nodes
}

// GetValue converts native DB type, array into []interface{}.
func (j JSONArray) GetValue() (nodes []interface{}, err error) {
	elts := jsonArraySlice(j.dpiJsonArray)
	for i := range elts {
		var d Data
		jsonNodeToData(&d, &elts[i])
		if d.NativeTypeNum == ( /*line :486:25*/_Ciconst_DPI_NATIVE_TYPE_JSON_OBJECT /*line :486:53*/) {

			jsobj := JSONObject{dpiJsonObject: ( /*line :488:39*/_Cfunc_dpiData_getJsonObject /*line :488:61*/)(&(d.dpiData))}
			m, err := jsobj.GetValue()
			if err != nil {
				return nil, err
			}
			nodes = append(nodes, m)
		} else if d.NativeTypeNum == ( /*line :494:32*/_Ciconst_DPI_NATIVE_TYPE_JSON_ARRAY /*line :494:59*/) {
			jsarr := JSONArray{dpiJsonArray: ( /*line :495:37*/_Cfunc_dpiData_getJsonArray /*line :495:58*/)(&(d.dpiData))}
			ua, err := jsarr.GetValue()
			if err != nil {
				return nil, err
			}
			nodes = append(nodes, ua)
		} else {
			if elts[i].oracleTypeNum == ( /*line :502:32*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :502:56*/) {
				keyval, err := getJSONScalarString(d)
				if err == nil {
					nodes = append(nodes, keyval)
				} else {
					return nil, err
				}
			} else if elts[i].oracleTypeNum == ( /*line :509:39*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :509:62*/) {
				nodes = append(nodes, getJSONScalarNumber(d))
			} else {
				nodes = append(nodes, d.Get())
			}
		}
	}
	return nodes, nil
}

func jsonArraySlice(arr * /*line :519:26*/_Ctype_dpiJsonArray /*line :519:40*/) [] /*line :519:44*/_Ctype_dpiJsonNode /*line :519:57*/ {
	n := int(arr.numElements)
	//return ((*[maxArraySize]C.dpiJsonNode)(unsafe.Pointer(arr.elements)))[:n:n]
	return unsafe.Slice(arr.elements, n)
}

// JSONObject represents the map input.
type JSONObject struct {
	dpiJsonObject * /*line :527:17*/_Ctype_dpiJsonObject /*line :527:32*/
}

// Len returns the number of keys in the JSONObject
func (j JSONObject) Len() int { return int(j.dpiJsonObject.numFields) }

// Get returns the map, map[string]Data from JSONObject
func (j JSONObject) Get() map[string]Data {
	ff := jsonObjectFields(j.dpiJsonObject)
	m := make(map[string]Data, len(ff))
	for _, f := range ff {
		var d Data
		jsonNodeToData(&d, f.Value)
		m[f.Name] = d
	}
	return m
}

// GetValue converts native DB type, array into map[string]interface{}.
func (j JSONObject) GetValue() (m map[string]interface{}, err error) {
	m = make(map[string]interface{})
	for _, f := range jsonObjectFields(j.dpiJsonObject) {
		var d Data
		jsonNodeToData(&d, f.Value)
		if d.NativeTypeNum == ( /*line :551:25*/_Ciconst_DPI_NATIVE_TYPE_JSON_OBJECT /*line :551:53*/) {
			jsobj := JSONObject{dpiJsonObject: ( /*line :552:39*/_Cfunc_dpiData_getJsonObject /*line :552:61*/)(&(d.dpiData))}
			um, err := jsobj.GetValue()
			if err != nil {
				return nil, err
			}
			m[f.Name] = um
		} else if d.NativeTypeNum == ( /*line :558:32*/_Ciconst_DPI_NATIVE_TYPE_JSON_ARRAY /*line :558:59*/) {
			jsobj := JSONArray{dpiJsonArray: ( /*line :559:37*/_Cfunc_dpiData_getJsonArray /*line :559:58*/)(&(d.dpiData))}
			ua, err := jsobj.GetValue()
			if err != nil {
				return nil, err
			}
			m[f.Name] = ua
		} else if f.Value.oracleTypeNum == ( /*line :565:38*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :565:62*/) {
			keyval, err := getJSONScalarString(d)
			if err == nil {
				m[f.Name] = keyval
			} else {
				return nil, err
			}
		} else if f.Value.oracleTypeNum == ( /*line :572:38*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :572:61*/) {
			m[f.Name] = getJSONScalarNumber(d)
		} else {
			m[f.Name] = d.Get()
		}
	}
	return m, nil
}

// GetInto takes pointer to struct and populates the fields.
// The struct name fields are matched with DB JSON keynames but
// not the struct json tags.
func (j JSONObject) GetInto(v interface{}) {
	rv := reflect.ValueOf(v).Elem()
	for _, f := range jsonObjectFields(j.dpiJsonObject) {
		var d Data
		jsonNodeToData(&d, f.Value)
		// nosemgrep: go.lang.security.audit.unsafe-reflect-by-name.unsafe-reflect-by-name
		rv.FieldByName(f.Name).Set(reflect.ValueOf(d.Get()))
	}
}

type jsonField struct {
	Name  string
	Value * /*line :596:9*/_Ctype_dpiJsonNode /*line :596:22*/
}

func jsonObjectFields(obj * /*line :599:28*/_Ctype_dpiJsonObject /*line :599:43*/) []jsonField {
	n := int(obj.numFields)
	//names := ((*[maxArraySize]*C.char)(unsafe.Pointer(obj.fieldNames)))[:n:n]
	names := unsafe.Slice(obj.fieldNames, n)
	//nameLengths := ((*[maxArraySize]C.uint32_t)(unsafe.Pointer(obj.fieldNameLengths)))[:n:n]
	nameLengths := unsafe.Slice(obj.fieldNameLengths, n)
	//fields := ((*[maxArraySize]C.dpiJsonNode)(unsafe.Pointer(obj.fields)))[:n:n]
	fields := unsafe.Slice(obj.fields, n)
	ff := make([]jsonField, n)
	for i := range fields {
		ff[i] = jsonField{
			Name:  ( /*line :610:11*/_Cfunc_GoStringN /*line :610:21*/)(names[i],  /*line :610:33*/_Ctype_int /*line :610:38*/(nameLengths[i])),
			Value: &fields[i],
		}
		func() { _cgo0 := /*line :613:10*/unsafe.Pointer(names[i]); _cgoCheckPointer(_cgo0, nil); /*line :613:35*/_Cfunc_free(_cgo0); }()
	}
	return ff
}

// populateJSONNode populates dpiJsonNode from user inputs.
// It creates a seperate memory for the new output value, jsonnode.
// memory from user input, in is not shared with jsonnode.
// Caller has to explicitly free using godror_dpiJsonfreeMem
func populateJSONNode(jsonnode * /*line :622:33*/_Ctype_dpiJsonNode /*line :622:46*/, in interface{}) error {
	switch x := in.(type) {
	case []interface{}:
		arr, _ := in.([]interface{})
		func() { _cgoBase0 := /*line :626:69*/&jsonnode; _cgo0 := /*line :626:36*/(**_Ctype_dpiJsonNode /*line :626:52*/)(unsafe.Pointer(_cgoBase0)); var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :626:92*/(len(arr)); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :626:103*/_Cfunc_godror_dpiJsonArray_initialize(_cgo0, _cgo1); }()

		var dpijsonarr * /*line :628:19*/_Ctype_dpiJsonArray /*line :628:33*/
		func() { _cgo0 := /*line :629:27*/jsonnode; _cgoBase1 := /*line :629:71*/&dpijsonarr; _cgo1 := /*line :629:37*/(**_Ctype_dpiJsonArray /*line :629:54*/)(unsafe.Pointer(_cgoBase1)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); /*line :629:85*/_Cfunc_godror_dpiasJsonArray(_cgo0, _cgo1); }()
		for index, entry := range arr {
			var jsonnodelocal * /*line :631:23*/_Ctype_dpiJsonNode /*line :631:36*/
			func() { _cgo0 := /*line :632:30*/dpijsonarr; var _cgo1 _Ctype_int = _Ctype_int /*line :632:47*/(index); _cgoBase2 := /*line :632:89*/&jsonnodelocal; _cgo2 := /*line :632:56*/(**_Ctype_dpiJsonNode /*line :632:72*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); /*line :632:106*/_Cfunc_godror_setArrayElements(_cgo0, _cgo1, _cgo2); }()
			err := populateJSONNode(jsonnodelocal, entry)
			if err != nil {
				return err
			}
		}
	case map[string]interface{}:
		m, _ := in.(map[string]interface{})
		// Initialize dpiJsonObjectNode
		func() { _cgoBase0 := /*line :641:70*/&jsonnode; _cgo0 := /*line :641:37*/(**_Ctype_dpiJsonNode /*line :641:53*/)(unsafe.Pointer(_cgoBase0)); var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :641:93*/(len(m)); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :641:102*/_Cfunc_godror_dpiJsonObject_initialize(_cgo0, _cgo1); }()

		var dpijsonobj * /*line :643:19*/_Ctype_dpiJsonObject /*line :643:34*/
		func() { _cgo0 := /*line :644:28*/jsonnode; _cgoBase1 := /*line :644:73*/&dpijsonobj; _cgo1 := /*line :644:38*/(**_Ctype_dpiJsonObject /*line :644:56*/)(unsafe.Pointer(_cgoBase1)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); /*line :644:87*/_Cfunc_godror_dpiasJsonObject(_cgo0, _cgo1); }()

		var i  /*line :646:9*/_Ctype_int /*line :646:14*/ = 0
		var cKey * /*line :647:13*/_Ctype_char /*line :647:19*/

		for k, v := range m {
			cKey = ( /*line :650:11*/_Cfunc_CString /*line :650:19*/)(k)
			func() { _cgo0 := /*line :651:34*/jsonnode; var _cgo1 _Ctype_int = /*line :651:44*/i; var _cgo2 *_Ctype_char = /*line :651:47*/cKey; var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t /*line :651:63*/(len(k)); _cgoCheckPointer(_cgo0, nil); /*line :651:72*/_Cfunc_godror_dpiJsonObject_setKey(_cgo0, _cgo1, _cgo2, _cgo3); }()
			func() { _cgo0 := /*line :652:11*/unsafe.Pointer(cKey); _cgoCheckPointer(_cgo0, nil); /*line :652:32*/_Cfunc_free(_cgo0); }()
			var jsonnodelocal * /*line :653:23*/_Ctype_dpiJsonNode /*line :653:36*/
			func() { _cgo0 := /*line :654:29*/dpijsonobj; var _cgo1 _Ctype_int = /*line :654:41*/i; _cgoBase2 := /*line :654:77*/&jsonnodelocal; _cgo2 := /*line :654:44*/(**_Ctype_dpiJsonNode /*line :654:60*/)(unsafe.Pointer(_cgoBase2)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); /*line :654:94*/_Cfunc_godror_setObjectFields(_cgo0, _cgo1, _cgo2); }()
			err := populateJSONNode(jsonnodelocal, v)
			if err != nil {
				return err
			}
			i = i + 1
		}

	case int:
		func() { _cgo0 := /*line :663:29*/jsonnode; var _cgo1 _Ctype_int64_t = _Ctype_int64_t /*line :663:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :663:52*/_Cfunc_godror_dpiJson_setInt64(_cgo0, _cgo1); }()
	case int8:
		func() { _cgo0 := /*line :665:29*/jsonnode; var _cgo1 _Ctype_int64_t = _Ctype_int64_t /*line :665:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :665:52*/_Cfunc_godror_dpiJson_setInt64(_cgo0, _cgo1); }()
	case int16:
		func() { _cgo0 := /*line :667:29*/jsonnode; var _cgo1 _Ctype_int64_t = _Ctype_int64_t /*line :667:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :667:52*/_Cfunc_godror_dpiJson_setInt64(_cgo0, _cgo1); }()
	case int32:
		func() { _cgo0 := /*line :669:29*/jsonnode; var _cgo1 _Ctype_int64_t = _Ctype_int64_t /*line :669:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :669:52*/_Cfunc_godror_dpiJson_setInt64(_cgo0, _cgo1); }()
	case int64:
		func() { _cgo0 := /*line :671:29*/jsonnode; var _cgo1 _Ctype_int64_t = _Ctype_int64_t /*line :671:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :671:52*/_Cfunc_godror_dpiJson_setInt64(_cgo0, _cgo1); }()
	case uint:
		func() { _cgo0 := /*line :673:30*/jsonnode; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :673:50*/(x); _cgoCheckPointer(_cgo0, nil); /*line :673:54*/_Cfunc_godror_dpiJson_setUint64(_cgo0, _cgo1); }()
	case uint8:
		func() { _cgo0 := /*line :675:30*/jsonnode; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :675:50*/(x); _cgoCheckPointer(_cgo0, nil); /*line :675:54*/_Cfunc_godror_dpiJson_setUint64(_cgo0, _cgo1); }()
	case uint16:
		func() { _cgo0 := /*line :677:30*/jsonnode; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :677:50*/(x); _cgoCheckPointer(_cgo0, nil); /*line :677:54*/_Cfunc_godror_dpiJson_setUint64(_cgo0, _cgo1); }()
	case uint32:
		func() { _cgo0 := /*line :679:30*/jsonnode; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :679:50*/(x); _cgoCheckPointer(_cgo0, nil); /*line :679:54*/_Cfunc_godror_dpiJson_setUint64(_cgo0, _cgo1); }()
	case uint64:
		func() { _cgo0 := /*line :681:30*/jsonnode; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :681:50*/(x); _cgoCheckPointer(_cgo0, nil); /*line :681:54*/_Cfunc_godror_dpiJson_setUint64(_cgo0, _cgo1); }()
	case float32:
		func() { _cgo0 := /*line :683:30*/jsonnode; var _cgo1 _Ctype_double = _Ctype_double /*line :683:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :683:52*/_Cfunc_godror_dpiJson_setDouble(_cgo0, _cgo1); }()
	case float64:
		func() { _cgo0 := /*line :685:30*/jsonnode; var _cgo1 _Ctype_double = _Ctype_double /*line :685:48*/(x); _cgoCheckPointer(_cgo0, nil); /*line :685:52*/_Cfunc_godror_dpiJson_setDouble(_cgo0, _cgo1); }()
	case Number:
		func() { _cgo0 := /*line :687:30*/jsonnode; var _cgo1 string = /*line :687:40*/x.String(); _cgoCheckPointer(_cgo0, nil); /*line :687:51*/_Cfunc_godror_dpiJson_setNumber(_cgo0, _cgo1); }()
	case string:
		data, err := NewData(x)
		if err != nil {
			return err
		}
		func() { _cgo0 := /*line :693:30*/jsonnode; var _cgo1 *_Ctype_struct_dpiData = /*line :693:40*/&(data.dpiData); _cgoCheckPointer(_cgo0, nil); /*line :693:56*/_Cfunc_godror_dpiJson_setString(_cgo0, _cgo1); }()
	case time.Time:
		data, err := NewData(x)
		if err != nil {
			return err
		}
		func() { _cgo0 := /*line :699:28*/jsonnode; var _cgo1 *_Ctype_struct_dpiData = /*line :699:38*/&(data.dpiData); _cgoCheckPointer(_cgo0, nil); /*line :699:54*/_Cfunc_godror_dpiJson_setTime(_cgo0, _cgo1); }()
	case time.Duration:
		data, err := NewData(x)
		if err != nil {
			return err
		}
		func() { _cgo0 := /*line :705:34*/jsonnode; var _cgo1 *_Ctype_struct_dpiData = /*line :705:44*/&(data.dpiData); _cgoCheckPointer(_cgo0, nil); /*line :705:60*/_Cfunc_godror_dpiJson_setIntervalDS(_cgo0, _cgo1); }()
	case []byte:
		data, err := NewData(x)
		if err != nil {
			return err
		}
		func() { _cgo0 := /*line :711:29*/jsonnode; var _cgo1 *_Ctype_struct_dpiData = /*line :711:39*/&(data.dpiData); _cgoCheckPointer(_cgo0, nil); /*line :711:55*/_Cfunc_godror_dpiJson_setBytes(_cgo0, _cgo1); }()
	case bool:
		data, err := NewData(x)
		if err != nil {
			return err
		}
		func() { _cgo0 := /*line :717:28*/jsonnode; var _cgo1 *_Ctype_struct_dpiData = /*line :717:38*/&(data.dpiData); _cgoCheckPointer(_cgo0, nil); /*line :717:54*/_Cfunc_godror_dpiJson_setBool(_cgo0, _cgo1); }()
	default:
		return fmt.Errorf("unsupported type %T", in)
	}
	return nil
}

// freedpiJSONNode deallocates the dpiJsonNode
func freedpiJSONNode(node * /*line :725:28*/_Ctype_dpiJsonNode /*line :725:41*/) error {
	func() { _cgo0 := /*line :726:26*/node; _cgoCheckPointer(_cgo0, nil); /*line :726:31*/_Cfunc_godror_dpiJsonfreeMem(_cgo0); }()
	return nil
}

// allocdpiJSONNode allocates dpiJsonNode from interface value, val
func allocdpiJSONNode(val interface{}, node ** /*line :731:47*/_Ctype_dpiJsonNode /*line :731:60*/) error {
	func() { _cgo0 := /*line :732:28*/(**_Ctype_dpiJsonNode /*line :732:44*/)(unsafe.Pointer(node)); _cgoCheckPointer(_cgo0, nil); /*line :732:68*/_Cfunc_godror_allocate_dpiNode(_cgo0); }()
	err := populateJSONNode(*node, val)
	if err != nil {
		func() { _cgo0 := /*line :735:27*/*node; _cgoCheckPointer(_cgo0, nil); /*line :735:33*/_Cfunc_godror_dpiJsonfreeMem(_cgo0); }()
	}
	return err
}
