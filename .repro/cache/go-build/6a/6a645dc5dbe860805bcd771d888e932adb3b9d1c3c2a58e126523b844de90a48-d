// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/data.go:1:1
// Copyright 2017, 2020 The Godror Authors
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package godror

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"context"
	"database/sql"
	"database/sql/driver"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strconv"
	"time"
	"unsafe"

	"github.com/godror/godror/slog"
)

// Data holds the data to/from Oracle.
type Data struct {
	ObjectType    *ObjectType
	dpiData        /*line :31:16*/_Ctype_dpiData /*line :31:25*/
	implicitObj   bool
	NativeTypeNum  /*line :33:16*/_Ctype_dpiNativeTypeNum /*line :33:34*/
}

var ErrNotSupported = errors.New("not supported")

// NewData creates a new Data structure for the given type, populated with the given type.
func NewData(v interface{}) (*Data, error) {
	if v == nil {
		return nil, fmt.Errorf("%s: %w", "nil type", ErrNotSupported)
	}
	data := Data{dpiData:  /*line :43:24*/_Ctype_dpiData /*line :43:33*/{isNull: 1}}
	return &data, data.Set(v)
}

// IsNull returns whether the data is null.
func (d *Data) IsNull() bool {
	// Use of C.dpiData_getIsNull(&d.dpiData) would be safer,
	// but ODPI-C 3.1.4 just returns dpiData->isNull, so do the same
	// without calling CGO.
	return d == nil || d.dpiData.isNull == 1
}

// SetNull sets the value of the data to be the null value.
func (d *Data) SetNull() {
	if !d.IsNull() {
		// Maybe C.dpiData_setNull(&d.dpiData) would be safer, but as we don't use C.dpiData_getIsNull,
		// and those functions (at least in ODPI-C 3.1.4) just operate on data->isNull directly,
		// don't use CGO if possible.
		d.dpiData.isNull = 1
	}
}

// GetBool returns the bool data.
func (d *Data) GetBool() bool {
	//return !d.IsNull() && C.dpiData_getBool(&d.dpiData) == 1
	return !d.IsNull() && *((* /*line :68:28*/_Ctype_int /*line :68:33*/)(unsafe.Pointer(&d.dpiData.value))) == 1
}

// SetBool sets the data as bool.
func (d *Data) SetBool(b bool) {
	var i  /*line :73:8*/_Ctype_int /*line :73:13*/
	if b {
		i = 1
	}
	d.NativeTypeNum = ( /*line :77:20*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :77:44*/)
	( /*line :78:2*/_Cfunc_dpiData_setBool /*line :78:18*/)(&d.dpiData, i)
}

// GetBytes returns the []byte from the data.
func (d *Data) GetBytes() []byte {
	if d.IsNull() {
		return nil
	}
	//b := C.dpiData_getBytes(&d.dpiData)
	b := ((* /*line :87:10*/_Ctype_dpiBytes /*line :87:20*/)(unsafe.Pointer(&d.dpiData.value)))
	if b.ptr == nil || b.length == 0 {
		return nil
	}
	//return ((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length]
	return ([]byte)(unsafe.Slice((*byte)(unsafe.Pointer(b.ptr)), b.length))
}

// SetBytes set the data as []byte.
func (d *Data) SetBytes(b []byte) {
	if len(b) == 0 { // yes, empty slice is NULL, too!
		d.dpiData.isNull = 1
		return
	}
	d.NativeTypeNum = ( /*line :101:20*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :101:42*/)
	( /*line :102:2*/_Cfunc_dpiData_setBytes /*line :102:19*/)(&d.dpiData, (* /*line :102:35*/_Ctype_char /*line :102:41*/)(unsafe.Pointer(&b[0])),  /*line :102:67*/_Ctype_uint32_t /*line :102:77*/(len(b)))
}

// GetFloat32 gets float32 from the data.
func (d *Data) GetFloat32() float32 {
	if d.IsNull() {
		return 0
	}
	//return float32(C.dpiData_getFloat(&d.dpiData))
	return *((*float32)(unsafe.Pointer(&d.dpiData.value)))
}

// SetFloat32 sets the data as float32.
func (d *Data) SetFloat32(f float32) {
	d.NativeTypeNum = ( /*line :116:20*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :116:42*/)
	( /*line :117:2*/_Cfunc_dpiData_setFloat /*line :117:19*/)(&d.dpiData,  /*line :117:33*/_Ctype_float /*line :117:40*/(f))
}

// GetFloat64 gets float64 from the data.
func (d *Data) GetFloat64() float64 {
	//fmt.Println("GetFloat64", d.IsNull(), d)
	if d.IsNull() {
		return 0
	}
	//return float64(C.dpiData_getDouble(&d.dpiData))
	return *((*float64)(unsafe.Pointer(&d.dpiData.value)))
}

// SetFloat64 sets the data as float64.
func (d *Data) SetFloat64(f float64) {
	d.NativeTypeNum = ( /*line :132:20*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :132:43*/)
	( /*line :133:2*/_Cfunc_dpiData_setDouble /*line :133:20*/)(&d.dpiData,  /*line :133:34*/_Ctype_double /*line :133:42*/(f))
}

// GetInt64 gets int64 from the data.
func (d *Data) GetInt64() int64 {
	if d.IsNull() {
		return 0
	}
	//i := C.dpiData_getInt64(&d.dpiData)
	i := *((*int64)(unsafe.Pointer(&d.dpiData.value)))
	if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("GetInt64", "data", d, "p", fmt.Sprintf("%p", d), "i", i)
	}

	return i
}

// SetInt64 sets the data as int64.
func (d *Data) SetInt64(i int64) {
	d.NativeTypeNum = ( /*line :152:20*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :152:42*/)
	( /*line :153:2*/_Cfunc_dpiData_setInt64 /*line :153:19*/)(&d.dpiData,  /*line :153:33*/_Ctype_int64_t /*line :153:42*/(i))
}

// GetIntervalDS gets duration as interval date-seconds from data.
func (d *Data) GetIntervalDS() time.Duration {
	if d.IsNull() {
		return 0
	}
	//ds := C.dpiData_getIntervalDS(&d.dpiData)
	ds := *((* /*line :162:12*/_Ctype_dpiIntervalDS /*line :162:27*/)(unsafe.Pointer(&d.dpiData.value)))
	return time.Duration(ds.days)*24*time.Hour +
		time.Duration(ds.hours)*time.Hour +
		time.Duration(ds.minutes)*time.Minute +
		time.Duration(ds.seconds)*time.Second +
		time.Duration(ds.fseconds)
}

// SetIntervalDS sets the duration as interval date-seconds to data.
func (d *Data) SetIntervalDS(dur time.Duration) {
	rem := dur % (24 * time.Hour)
	days :=  /*line :173:10*/_Ctype_int32_t /*line :173:19*/(dur / (24 * time.Hour))
	dur, rem = rem, dur%(time.Hour)
	hrs :=  /*line :175:9*/_Ctype_int32_t /*line :175:18*/(dur / time.Hour)
	dur, rem = rem, dur%(time.Minute)
	mins :=  /*line :177:10*/_Ctype_int32_t /*line :177:19*/(dur / time.Minute)
	dur, rem = rem, dur%time.Second
	secs :=  /*line :179:10*/_Ctype_int32_t /*line :179:19*/(dur / time.Second)
	fsecs :=  /*line :180:11*/_Ctype_int32_t /*line :180:20*/(rem)
	d.NativeTypeNum = ( /*line :181:20*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :181:48*/)
	( /*line :182:2*/_Cfunc_dpiData_setIntervalDS /*line :182:24*/)(&d.dpiData, days, hrs, mins, secs, fsecs)
}

// GetIntervalYM gets IntervalYM from the data.
func (d *Data) GetIntervalYM() IntervalYM {
	if d.IsNull() {
		return IntervalYM{}
	}
	//ym := C.dpiData_getIntervalYM(&d.dpiData)
	ym := *((* /*line :191:12*/_Ctype_dpiIntervalYM /*line :191:27*/)(unsafe.Pointer(&d.dpiData.value)))
	return IntervalYM{Years: int(ym.years), Months: int(ym.months)}
}

// SetIntervalYM sets IntervalYM to the data.
func (d *Data) SetIntervalYM(ym IntervalYM) {
	d.NativeTypeNum = ( /*line :197:20*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :197:48*/)
	( /*line :198:2*/_Cfunc_dpiData_setIntervalYM /*line :198:24*/)(&d.dpiData,  /*line :198:38*/_Ctype_int32_t /*line :198:47*/(ym.Years),  /*line :198:59*/_Ctype_int32_t /*line :198:68*/(ym.Months))
}

// GetLob gets data as Lob.
func (d *Data) GetLob() *Lob {
	if d.IsNull() {
		return nil
	}
	return &Lob{Reader: &dpiLobReader{dpiLob: ( /*line :206:44*/_Cfunc_dpiData_getLOB /*line :206:59*/)(&d.dpiData)}}
}

// SetLob sets Lob to the data.
func (d *Data) SetLob(lob *DirectLob) {
	d.NativeTypeNum = ( /*line :211:20*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :211:40*/)
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :212:19*/&d.dpiData; _cgo1 := /*line :212:31*/lob.dpiLob; _cgoCheckPointer(_cgo1, nil); /*line :212:42*/_Cfunc_dpiData_setLOB(_cgo0, _cgo1); }()
}

// GetObject gets Object from data.
//
// As with all Objects, you MUST call Close on it when not needed anymore!
func (d *Data) GetObject() *Object {
	if d == nil {
		panic("null")
	}
	if d.IsNull() {
		return nil
	}

	o := ( /*line :226:7*/_Cfunc_dpiData_getObject /*line :226:25*/)(&d.dpiData)
	if o == nil {
		return nil
	}
	if !d.implicitObj {
		if err := d.ObjectType.drv.checkExec(func()  /*line :231:47*/_Ctype_int /*line :231:52*/ {
			return func() _Ctype_int{ _cgo0 := /*line :232:30*/o; _cgoCheckPointer(_cgo0, nil); return /*line :232:32*/_Cfunc_dpiObject_addRef(_cgo0); }()
		}); err != nil {
			panic(err)
		}
	}
	obj := &Object{dpiObject: o, ObjectType: d.ObjectType}
	if err := obj.init(nil); err != nil {
		panic(err)
	}
	return obj
}

// SetObject sets Object to data.
func (d *Data) SetObject(o *Object) {
	d.NativeTypeNum = ( /*line :246:20*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :246:43*/)
	if o == nil {
		d.SetNull()
		return
	}
	d.ObjectType = o.ObjectType
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :252:22*/&d.dpiData; _cgo1 := /*line :252:34*/o.dpiObject; _cgoCheckPointer(_cgo1, nil); /*line :252:46*/_Cfunc_dpiData_setObject(_cgo0, _cgo1); }()
}

// GetStmt gets Stmt from data.
func (d *Data) GetStmt() driver.Stmt {
	if d.IsNull() {
		return nil
	}
	return &statement{dpiStmt: ( /*line :260:29*/_Cfunc_dpiData_getStmt /*line :260:45*/)(&d.dpiData)}
}

// SetStmt sets Stmt to data.
func (d *Data) SetStmt(s *statement) {
	d.NativeTypeNum = ( /*line :265:20*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :265:41*/)
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :266:20*/&d.dpiData; _cgo1 := /*line :266:32*/s.dpiStmt; _cgoCheckPointer(_cgo1, nil); /*line :266:42*/_Cfunc_dpiData_setStmt(_cgo0, _cgo1); }()
}

// GetTime gets Time from data, in the local time zone.
func (d *Data) GetTime() time.Time {
	return d.GetTimeIn(time.Local)
}

// GetTimeIn gets Time from data using the given Location (use the server's for correct value).
func (d *Data) GetTimeIn(serverTZ *time.Location) time.Time {
	if d.IsNull() {
		return time.Time{}
	}
	//ts := C.dpiData_getTimestamp(&d.dpiData)
	ts := *((* /*line :280:12*/_Ctype_dpiTimestamp /*line :280:26*/)(unsafe.Pointer(&d.dpiData.value)))
	return time.Date(
		int(ts.year), time.Month(ts.month), int(ts.day),
		int(ts.hour), int(ts.minute), int(ts.second), int(ts.fsecond),
		timeZoneFor(ts.tzHourOffset, ts.tzMinuteOffset, serverTZ),
	)
}

// SetTime sets Time to data.
func (d *Data) SetTime(t time.Time) {
	d.dpiData.isNull =  /*line :290:21*/_Ctype_int /*line :290:26*/(b2i(t.IsZero()))
	if d.dpiData.isNull == 1 {
		return
	}
	d.NativeTypeNum = ( /*line :294:20*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :294:46*/)
	dataSetTime(&d.dpiData, t, nil)
}

func dataSetTime(dpiData * /*line :298:27*/_Ctype_dpiData /*line :298:36*/, t time.Time, connTZ *time.Location) {
	logger := getLogger(context.TODO())
	tz, tzOff := connTZ, 0
	if tz == nil {
		tz = t.Location()
	}
	if tz != time.UTC && // Against ORA-08192
		date8192begin.Before(t) && date8192end.After(t) {
		tz = time.UTC
	}
	if t.Location() != tz {
		t = t.In(tz)
	}
	if tz != time.UTC {
		_, tzOff = t.Zone()
	}
	Y, M, D := t.Date()
	if Y <= 0 { // Oracle skips year 0, 0001-01-01 follows -0001-12-31 !
		Y--
	}
	if -4713 > Y || Y == 0 || 9999 < Y { // Against ORA-01841
		panic(fmt.Errorf("%v: %w", t, ErrBadDate))
	}
	h, m, s := t.Clock()
	ns := t.Nanosecond()
	// DST transition creates a gap and both times may be correct.
	if (h == 1 || h == 23) && m == 0 && s == 0 && ns == 0 &&
		tz != nil && tz != time.UTC {
		zs, ze := t.ZoneBounds()
		if zs.Equal(t) || ze.Equal(t) {
			h = 0
		}
		// fmt.Printf("bounds: %s - %s (%s -> h=%d)\n", zs, ze, t, h)
	}
	if logger != nil {
		logger.Debug("setTimestamp", "time", t.Format(time.RFC3339), "utc", t.UTC(), "tz", tzOff,
			"Y", Y, "M", M, "D", D, "h", h, "m", m, "s", s, "t", ns,
			"tzHour", tzOff/3600, "tzMin", (tzOff%3600)/60)
	}

	( /*line :338:2*/_Cfunc_dpiData_setTimestamp /*line :338:23*/)(dpiData,
		 /*line :339:3*/_Ctype_int16_t /*line :339:12*/(Y),  /*line :339:17*/_Ctype_uint8_t /*line :339:26*/(M),  /*line :339:31*/_Ctype_uint8_t /*line :339:40*/(D),
		 /*line :340:3*/_Ctype_uint8_t /*line :340:12*/(h),  /*line :340:17*/_Ctype_uint8_t /*line :340:26*/(m),  /*line :340:31*/_Ctype_uint8_t /*line :340:40*/(s),  /*line :340:45*/_Ctype_uint32_t /*line :340:55*/(ns),
		 /*line :341:3*/_Ctype_int8_t /*line :341:11*/(tzOff/3600),  /*line :341:25*/_Ctype_int8_t /*line :341:33*/((tzOff%3600)/60),
	)
}

// GetUint64 gets data as uint64.
func (d *Data) GetUint64() uint64 {
	if d.IsNull() {
		return 0
	}
	//return uint64(C.dpiData_getUint64(&d.dpiData))
	return *((*uint64)(unsafe.Pointer(&d.dpiData.value)))
}

// SetUint64 sets data to uint64.
func (d *Data) SetUint64(u uint64) {
	d.NativeTypeNum = ( /*line :356:20*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :356:43*/)
	( /*line :357:2*/_Cfunc_dpiData_setUint64 /*line :357:20*/)(&d.dpiData,  /*line :357:34*/_Ctype_uint64_t /*line :357:44*/(u))
}

// IntervalYM holds Years and Months as interval.
type IntervalYM struct {
	Years, Months int
}

// Get returns the contents of Data.
func (d *Data) Get() interface{} {
	if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("Get", "data", fmt.Sprintf("%#v", d), "p", fmt.Sprintf("%p", d))
	}
	switch d.NativeTypeNum {
	case 0:
		return nil
	case ( /*line :373:7*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :373:31*/):
		return d.GetBool()
	case ( /*line :375:7*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :375:29*/):
		return d.GetBytes()
	case ( /*line :377:7*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :377:30*/):
		return d.GetFloat64()
	case ( /*line :379:7*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :379:29*/):
		return d.GetFloat32()
	case ( /*line :381:7*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :381:29*/):
		return d.GetInt64()
	case ( /*line :383:7*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :383:35*/):
		return d.GetIntervalDS()
	case ( /*line :385:7*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :385:35*/):
		return d.GetIntervalYM()
	case ( /*line :387:7*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :387:27*/):
		return d.GetLob()
	case ( /*line :389:7*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :389:30*/):
		return d.GetObject()
	case ( /*line :391:7*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :391:28*/):
		return d.GetStmt()
	case ( /*line :393:7*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :393:33*/):
		return d.GetTime()
	case ( /*line :395:7*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :395:30*/):
		return d.GetUint64()
	case ( /*line :397:7*/_Ciconst_DPI_NATIVE_TYPE_JSON_ARRAY /*line :397:34*/):
		return d.GetJSONArray()
	case ( /*line :399:7*/_Ciconst_DPI_NATIVE_TYPE_JSON_OBJECT /*line :399:35*/):
		return d.GetJSONObject()
	default:
		panic("unknown NativeTypeNum=" + strconv.FormatInt(int64(d.NativeTypeNum), 10))
	}
}

// Set the data.
func (d *Data) Set(v interface{}) error {
	if v == nil {
		return fmt.Errorf("%s: %w", "nil type", ErrNotSupported)
	}
	switch x := v.(type) {
	case int8:
		d.SetInt64(int64(x))
	case int16:
		d.SetInt64(int64(x))
	case int32:
		d.SetInt64(int64(x))
	case sql.NullInt32:
		if x.Valid {
			d.SetInt64(int64(x.Int32))
		} else {
			d.SetNull()
		}
	case int64:
		d.SetInt64(x)
	case sql.NullInt64:
		if x.Valid {
			d.SetInt64(x.Int64)
		} else {
			d.SetNull()
		}
	case int:
		d.SetInt64(int64(x))
	case uint8:
		d.SetUint64(uint64(x))
	case uint16:
		d.SetUint64(uint64(x))
	case uint32:
		d.SetUint64(uint64(x))
	case uint64:
		d.SetUint64(x)
	case uint:
		d.SetUint64(uint64(x))
	case float32:
		d.SetFloat32(x)
	case float64:
		d.SetFloat64(x)
	case sql.NullFloat64:
		if x.Valid {
			d.SetFloat64(x.Float64)
		} else {
			d.SetNull()
		}
	case string:
		d.SetBytes([]byte(x))
	case []byte:
		d.SetBytes(x)
	case time.Time:
		d.SetTime(x)
	case NullTime:
		d.NativeTypeNum = ( /*line :461:21*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :461:47*/)
		if d.dpiData.isNull =  /*line :462:25*/_Ctype_int /*line :462:30*/(b2i(!x.Valid)); x.Valid {
			d.SetTime(x.Time)
		}
	case time.Duration:
		d.SetIntervalDS(x)
	case IntervalYM:
		d.SetIntervalYM(x)
	case *Lob:
		b, err := io.ReadAll(x.Reader)
		if err != nil {
			return err
		}
		d.SetBytes(b)
	case *DirectLob:
		d.SetLob(x)
	case *Object:
		d.ObjectType = x.ObjectType
		d.SetObject(x)
	case ObjectCollection:
		d.ObjectType = x.Object.ObjectType
		d.SetObject(x.Object)
	//case *stmt:
	//d.NativeTypeNum = C.DPI_NATIVE_TYPE_STMT
	//d.SetStmt(x)
	case bool:
		d.SetBool(x)
	case sql.NullBool:
		if x.Valid {
			d.SetBool(x.Bool)
		} else {
			d.SetNull()
		}
	//case rowid:
	//d.NativeTypeNum = C.DPI_NATIVE_TYPE_ROWID
	//d.SetRowid(x)
	default:
		if logger := getLogger(context.TODO()); logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
			logger.Debug("Set", "data", d, "type", fmt.Sprintf("%T", v))
		}

		return fmt.Errorf("data Set type %T: %w", v, ErrNotSupported)
	}
	logger := getLogger(context.TODO())
	if logger != nil {
		logger.Debug("Set", "data", d)
	}
	return nil
}

// IsObject returns whether the data contains an Object or not.
func (d *Data) IsObject() bool {
	return d.NativeTypeNum == ( /*line :513:28*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :513:51*/)
}

// NewData returns Data for input parameters on Object/ObjectCollection.
func (c *conn) NewData(baseType interface{}, sliceLen, bufSize int) ([]*Data, error) {
	if c == nil || c.dpiConn == nil {
		return nil, errors.New("connection is nil")
	}

	vi, err := newVarInfo(baseType, sliceLen, bufSize)
	if err != nil {
		return nil, err
	}

	v, dpiData, err := c.newVar(vi)
	if err != nil {
		return nil, err
	}
	defer func() func() { _cgo0 := /*line :531:25*/v; return func() { _cgoCheckPointer(_cgo0, nil); /*line :531:27*/_Cfunc_dpiVar_release(_cgo0); }}()()

	data := make([]*Data, sliceLen)
	for i := 0; i < sliceLen; i++ {
		data[i] = &Data{dpiData: dpiData[i], NativeTypeNum: vi.NatTyp}
	}

	return data, nil
}

func newVarInfo(baseType interface{}, sliceLen, bufSize int) (varInfo, error) {
	var vi varInfo

	switch v := baseType.(type) {
	case Lob, []Lob:
		vi.NatTyp = ( /*line :546:15*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :546:35*/)
		var isClob bool
		switch v := v.(type) {
		case Lob:
			isClob = v.IsClob
		case []Lob:
			isClob = len(v) > 0 && v[0].IsClob
		}
		if isClob {
			vi.Typ = ( /*line :555:13*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :555:34*/)
		} else {
			vi.Typ = ( /*line :557:13*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :557:34*/)
		}
	case Number, []Number:
		vi.Typ, vi.NatTyp = ( /*line :560:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :560:46*/), ( /*line :560:49*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :560:71*/)
	case int, []int, int64, []int64, sql.NullInt64, []sql.NullInt64:
		vi.Typ, vi.NatTyp = ( /*line :562:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :562:46*/), ( /*line :562:49*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :562:71*/)
	case int8, []int8, int16, []int16, int32, []int32, sql.NullInt32, []sql.NullInt32:
		vi.Typ, vi.NatTyp = ( /*line :564:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :564:50*/), ( /*line :564:53*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :564:75*/)
	case uint, []uint, uint64, []uint64:
		vi.Typ, vi.NatTyp = ( /*line :566:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :566:46*/), ( /*line :566:49*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :566:72*/)
	case uint8, uint16, []uint16, uint32, []uint32:
		vi.Typ, vi.NatTyp = ( /*line :568:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :568:51*/), ( /*line :568:54*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :568:77*/)
	case float32, []float32:
		vi.Typ, vi.NatTyp = ( /*line :570:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :570:52*/), ( /*line :570:55*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :570:77*/)
	case float64, []float64, sql.NullFloat64, []sql.NullFloat64:
		vi.Typ, vi.NatTyp = ( /*line :572:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :572:53*/), ( /*line :572:56*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :572:79*/)
	case bool, []bool:
		vi.Typ, vi.NatTyp = ( /*line :574:23*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :574:47*/), ( /*line :574:50*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :574:74*/)
	case []byte, [][]byte:
		vi.Typ, vi.NatTyp = ( /*line :576:23*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :576:43*/), ( /*line :576:46*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :576:68*/)
		switch v := v.(type) {
		case []byte:
			bufSize = len(v)
		case [][]byte:
			for _, b := range v {
				if n := len(b); n > bufSize {
					bufSize = n
				}
			}
		}
	case string, []string, nil:
		vi.Typ, vi.NatTyp = ( /*line :588:23*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :588:47*/), ( /*line :588:50*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :588:72*/)
		bufSize = 32767
	case time.Time, NullTime:
		vi.Typ, vi.NatTyp = ( /*line :591:23*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_TZ /*line :591:52*/), ( /*line :591:55*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :591:81*/)
	case []time.Time, []NullTime:
		// Maybe vi.Typ should be C.DPI_ORACLE_TYPE_DATE
		vi.Typ, vi.NatTyp = ( /*line :594:23*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_TZ /*line :594:52*/), ( /*line :594:55*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :594:81*/)
	case userType, []userType:
		vi.Typ, vi.NatTyp = ( /*line :596:23*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :596:46*/), ( /*line :596:49*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :596:72*/)
		switch v := v.(type) {
		case userType:
			vi.ObjectType = v.ObjectRef().ObjectType.dpiObjectType
		case []userType:
			if len(v) > 0 {
				vi.ObjectType = v[0].ObjectRef().ObjectType.dpiObjectType
			}
		}
	default:
		return vi, fmt.Errorf("unknown type %T", v)
	}

	vi.IsPLSArray = reflect.TypeOf(baseType).Kind() == reflect.Slice
	vi.SliceLen = sliceLen
	vi.BufSize = bufSize

	return vi, nil
}

func (d *Data) reset() {
	d.NativeTypeNum = 0
	d.ObjectType = nil
	d.implicitObj = false
	d.SetBytes(nil)
	d.dpiData.isNull = 1
}

func (d *Data) dpiDataGetBytes() * /*line :624:35*/_Ctype_dpiBytes /*line :624:45*/ { return ( /*line :624:55*/_Cfunc_dpiData_getBytes /*line :624:72*/)(&d.dpiData) }
func (d *Data) dpiDataGetBytesUnsafe() * /*line :625:41*/_Ctype_dpiBytes /*line :625:51*/ {
	return ((* /*line :626:12*/_Ctype_dpiBytes /*line :626:22*/)(unsafe.Pointer(&d.dpiData.value)))
}

func (d *Data) GetJSON() JSON {
	return JSON{dpiJson: ((* /*line :630:26*/_Ctype_dpiJson /*line :630:35*/)(unsafe.Pointer(&d.dpiData.value)))}
}
func (d *Data) GetJSONObject() JSONObject {
	return JSONObject{dpiJsonObject: ((* /*line :633:38*/_Ctype_dpiJsonObject /*line :633:53*/)(unsafe.Pointer(&d.dpiData.value)))}
}
func (d *Data) GetJSONArray() JSONArray {
	return JSONArray{dpiJsonArray: ((* /*line :636:36*/_Ctype_dpiJsonArray /*line :636:50*/)(unsafe.Pointer(&d.dpiData.value)))}
}

// For tests
var _, _ = ((*Data)(nil)).dpiDataGetBytes, ((*Data)(nil)).dpiDataGetBytesUnsafe
