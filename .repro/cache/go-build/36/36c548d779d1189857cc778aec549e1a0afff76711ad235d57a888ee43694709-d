// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/username/go/pkg/mod/github.com/godror/godror@v0.41.0/drv.go:1:1
// Copyright 2019, 2023 The Godror Authors
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

// Package godror is a database/sql/driver for Oracle DB.
//
// The connection string for the sql.Open("godror", dataSourceName) call can be
// the simple
//
//	user="login" password="password" connectString="host:port/service_name" sysdba=true
//
// with additional params (here with the defaults):
//
//	sysdba=0
//	sysoper=0
//	poolMinSessions=1
//	poolMaxSessions=1000
//	poolMaxSessionsPerShard=
//	poolPingInterval=
//	poolIncrement=1
//	connectionClass=
//	standaloneConnection=0
//	enableEvents=0
//	heterogeneousPool=0
//	externalAuth=0
//	prelim=0
//	poolWaitTimeout=5m
//	poolSessionMaxLifetime=1h
//	poolSessionTimeout=30s
//	timezone=
//	noTimezoneCheck=
//	newPassword=
//	onInit="ALTER SESSION SET current_schema=my_schema"
//	configDir=
//	libDir=
//	stmtCacheSize=
//	charset=UTF-8
//
// These are the defaults.
// For external authentication, user and password should be empty
// with default value(0) for heterogeneousPool parameter.
// heterogeneousPool(valid for standaloneConnection=0)
// and externalAuth parameters are internally set. For Proxy
// support , sessionuser is enclosed in brackets [sessionuser].
//
// To use a heterogeneous Pool with Proxy Support ,user and password
// parameters should be non-empty and parameter heterogeneousPool should be 1.
// If user,password are empty and heterogeneousPool is set to 1,
// different user and password can be passed in subsequent queries.
//
// Many advocate that a static session pool (min=max, incr=0)
// is better, with 1-10 sessions per CPU thread.
// See https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7DFBA826-7CC0-4D16-B19C-31D168069B54
// You may also use ConnectionParams to configure a connection.
//
// If you specify connectionClass, that'll reuse the same session pool
// without the connectionClass, but will specify it on each session acquire.
// Thus you can cluster the session pool with classes.
//
// For connectionClass usage, see https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-CE6E4DCC-92DF-4946-92B8-2BDD9845DA35
//
// If you specify server_type as POOLED in sid, DRCP is used.
// For what can be used as "sid", see https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-E5358DEA-D619-4B7B-A799-3D2F802500F1
//
// Go strings are UTF-8, so the default charset should be used unless there's a really good reason to interfere with Oracle's character set conversion.
package godror; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -I./odpi/include -I./odpi/src -I./odpi/embed

#include "dpi.c"

*/
import _ "unsafe"

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"database/sql/driver"
	"errors"
	"fmt"
	"github.com/godror/godror/slog"
	"io"
	"math"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"
	"unsafe"

	"github.com/godror/godror/dsn"
)

const (
	// DefaultFetchArraySize is the fetch array size by default (if not changed through FetchArraySize statement option).
	DefaultFetchArraySize = ( /*line :100:26*/_Ciconst_DPI_DEFAULT_FETCH_ARRAY_SIZE /*line :100:55*/)

	// DefaultPrefetchCountis the number of prefetched rows by default (if not changed through PrefetchCount statement option).
	DefaultPrefetchCount = DefaultFetchArraySize

	// DefaultArraySize is the length of the maximum PL/SQL array by default (if not changed through ArraySize statement option).
	DefaultArraySize = 1 << 10

	baseWaitTimeout = 30 * time.Second
)

// DriverName is set on the connection to be seen in the DB
//
// It cannot be longer than 30 bytes !
var DriverName = "godror : " + Version

const (
	// DpiMajorVersion is the wanted major version of the underlying ODPI-C library.
	DpiMajorVersion = ( /*line :118:20*/_Ciconst_DPI_MAJOR_VERSION /*line :118:38*/)
	// DpiMinorVersion is the wanted minor version of the underlying ODPI-C library.
	DpiMinorVersion = ( /*line :120:20*/_Ciconst_DPI_MINOR_VERSION /*line :120:38*/)
	// DpiPatchLevel is the patch level version of the underlying ODPI-C library
	DpiPatchLevel = ( /*line :122:18*/_Ciconst_DPI_PATCH_LEVEL /*line :122:34*/)
	// DpiVersionNumber is the underlying ODPI-C version as one number (Major * 10000 + Minor * 100 + Patch)
	DpiVersionNumber = ( /*line :124:21*/_Ciconst_DPI_VERSION_NUMBER /*line :124:40*/)

	// DefaultPoolMinSessions specifies the default value for minSessions for pool creation.
	DefaultPoolMinSessions = dsn.DefaultPoolMinSessions
	// DefaultPoolMaxSessions specifies the default value for maxSessions for pool creation.
	DefaultPoolMaxSessions = dsn.DefaultPoolMaxSessions
	// DefaultSessionIncrement specifies the default value for increment for pool creation.
	DefaultSessionIncrement = dsn.DefaultSessionIncrement
	// DefaultPoolIncrement is a deprecated name for DefaultSessionIncrement.
	DefaultPoolIncrement = DefaultSessionIncrement
	// DefaultConnectionClass is empty, which allows to use the poolMinSessions created as part of session pool creation for non-DRCP. For DRCP, connectionClass needs to be explicitly mentioned.
	DefaultConnectionClass = dsn.DefaultConnectionClass
	// NoConnectionPoolingConnectionClass is a special connection class name to indicate no connection pooling.
	// It is the same as setting standaloneConnection=1
	NoConnectionPoolingConnectionClass = dsn.NoConnectionPoolingConnectionClass
	// DefaultSessionTimeout is the seconds before idle pool sessions get evicted
	DefaultSessionTimeout = dsn.DefaultSessionTimeout
	// DefaultWaitTimeout is the milliseconds to wait for a session to become available
	DefaultWaitTimeout = dsn.DefaultWaitTimeout
	// DefaultMaxLifeTime is the maximum time in seconds till a pooled session may exist
	DefaultMaxLifeTime = dsn.DefaultMaxLifeTime
	//DefaultStandaloneConnection holds the default for standaloneConnection.
	DefaultStandaloneConnection = dsn.DefaultStandaloneConnection
)

// dsn is separated out for fuzzing, but keep it as "internal"
type (
	ConnectionParams = dsn.ConnectionParams
	CommonParams     = dsn.CommonParams
	ConnParams       = dsn.ConnParams
	PoolParams       = dsn.PoolParams
	Password         = dsn.Password
)

// ParseConnString is deprecated, use ParseDSN.
func ParseConnString(s string) (ConnectionParams, error) { return dsn.Parse(s) }

// ParseDSN parses the given dataSourceName and returns a ConnectionParams structure for use in sql.OpenDB(godror.NewConnector(P)).
func ParseDSN(dataSourceName string) (P ConnectionParams, err error) {
	return dsn.Parse(dataSourceName)
}

func NewPassword(s string) Password { return dsn.NewPassword(s) }

var defaultDrv = &drv{}

func init() {
	sql.Register("godror", defaultDrv)
	// It cannot be longer than 30 bytes !
	if len(DriverName) > 30 {
		DriverName = DriverName[:30]
	}
}

var _ driver.Driver = (*drv)(nil)

type drv struct {
	dpiContext    * /*line :181:17*/_Ctype_dpiContext /*line :181:29*/
	pools         map[string]*connPool
	timezones     map[string]locationWithOffSecs
	clientVersion VersionInfo
	mu            sync.RWMutex
}

func NewDriver() *drv { return &drv{} }
func (d *drv) Close() error {
	if d == nil {
		return nil
	}
	d.mu.Lock()
	defer d.mu.Unlock()
	dpiCtx, pools := d.dpiContext, d.pools
	d.dpiContext, d.pools, d.timezones = nil, nil, nil
	done := make(chan error, 1)
	go func() {
		for _, pool := range pools {
			pool.Purge()
		}
		done <- nil
	}()
	select {
	case <-done:
	case <-time.After(baseWaitTimeout):
	}

	go func() {
		if func() _Ctype_int{ _cgo0 := /*line :210:27*/dpiCtx; _cgoCheckPointer(_cgo0, nil); return /*line :210:34*/_Cfunc_dpiContext_destroy(_cgo0); }() == ( /*line :210:38*/_Ciconst_DPI_FAILURE /*line :210:50*/) {
			done <- fmt.Errorf("error destroying dpiContext %p", dpiCtx)
		}
		close(done)
	}()
	select {
	case err := <-done:
		return err
	case <-time.After(baseWaitTimeout):
		return fmt.Errorf("Driver.Close: %w", context.DeadlineExceeded)
	}
}

type locationWithOffSecs struct {
	*time.Location
	offSecs int
}
type connPool struct {
	dpiPool * /*line :228:11*/_Ctype_dpiPool /*line :228:20*/
	key     string
	params  commonAndPoolParams
}

// Purge force-closes the pool's connections then closes the pool.
func (p *connPool) Purge() {
	dpiPool := p.dpiPool
	p.dpiPool = nil
	if dpiPool != nil {
		func() _Ctype_int{ _cgo0 := /*line :238:19*/dpiPool; var _cgo1 _Ctype_uint = /*line :238:28*/_Ciconst_DPI_MODE_POOL_CLOSE_FORCE /*line :238:55*/; _cgoCheckPointer(_cgo0, nil); return /*line :238:56*/_Cfunc_dpiPool_close(_cgo0, _cgo1); }()
	}
}

func (p *connPool) Close() error {
	dpiPool := p.dpiPool
	p.dpiPool = nil
	if dpiPool != nil {
		func() _Ctype_int{ _cgo0 := /*line :246:21*/dpiPool; _cgoCheckPointer(_cgo0, nil); return /*line :246:29*/_Cfunc_dpiPool_release(_cgo0); }()
	}
	return nil
}

func (d *drv) checkExec(f func()  /*line :251:34*/_Ctype_int /*line :251:39*/) error {
	runtime.LockOSThread()
	err := d.checkExecNoLOT(f)
	runtime.UnlockOSThread()
	return err
}

func (d *drv) checkExecNoLOT(f func()  /*line :258:39*/_Ctype_int /*line :258:44*/) error {
	if f() != ( /*line :259:12*/_Ciconst_DPI_FAILURE /*line :259:24*/) {
		return nil
	}
	return d.getError()
}

func (d *drv) init(configDir, libDir string) error {
	d.mu.RLock()
	ok := d.pools != nil && d.timezones != nil && d.dpiContext != nil
	d.mu.RUnlock()
	if ok {
		return nil
	}
	d.mu.Lock()
	defer d.mu.Unlock()
	if d.pools == nil {
		d.pools = make(map[string]*connPool)
	}
	if d.timezones == nil {
		d.timezones = make(map[string]locationWithOffSecs)
	}
	if d.dpiContext != nil {
		return nil
	}
	ctxParams := new( /*line :283:19*/_Ctype_dpiContextCreateParams /*line :283:43*/)
	ctxParams.defaultDriverName, ctxParams.defaultEncoding = cDriverName, cUTF8
	if !(configDir == "" && libDir == "") {
		if configDir != "" {
			ctxParams.oracleClientConfigDir = ( /*line :287:38*/_Cfunc_CString /*line :287:46*/)(configDir)
		}
		if libDir != "" {
			ctxParams.oracleClientLibDir = ( /*line :290:35*/_Cfunc_CString /*line :290:43*/)(libDir)
		}
	}
	logger := getLogger(context.TODO())
	if logger != nil {
		logger.Debug("dpiContext_createWithParams", "params", ctxParams)
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	var errInfo  /*line :301:14*/_Ctype_dpiErrorInfo /*line :301:28*/
	if func() _Ctype_int{ var _cgo0 _Ctype_uint = _Ctype_uint /*line :302:41*/(DpiMajorVersion); var _cgo1 _Ctype_uint = _Ctype_uint /*line :302:66*/(DpiMinorVersion); _cgo2 := /*line :303:3*/ctxParams; _cgoBase3 := /*line :304:35*/&d.dpiContext; _cgo3 := /*line :304:3*/(**_Ctype_dpiContext /*line :304:18*/)(unsafe.Pointer(_cgoBase3)); _cgoBase4 := /*line :304:52*/&errInfo; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :305:3*/_Cfunc_dpiContext_createWithParams(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == ( /*line :305:7*/_Ciconst_DPI_FAILURE /*line :305:19*/) {
		return fromErrorInfo(errInfo)
	}

	var v  /*line :309:8*/_Ctype_dpiVersionInfo /*line :309:24*/
	if func() _Ctype_int{ _cgo0 := /*line :310:35*/d.dpiContext; var _cgo1 *_Ctype_struct_dpiVersionInfo = /*line :310:49*/&v; _cgoCheckPointer(_cgo0, nil); return /*line :310:52*/_Cfunc_dpiContext_getClientVersion(_cgo0, _cgo1); }() == ( /*line :310:56*/_Ciconst_DPI_FAILURE /*line :310:68*/) {
		return fmt.Errorf("getClientVersion: %w", d.getError())
	}
	d.clientVersion.set(&v)
	return nil
}

// Open returns a new connection to the database.
// The name is a string in a driver-specific format.
func (d *drv) Open(s string) (driver.Conn, error) {
	c, err := d.OpenConnector(s)
	if err != nil {
		return nil, err
	}
	return d.createConnFromParams(context.Background(), c.(connector).ConnectionParams)
}

func (d *drv) ClientVersion() (VersionInfo, error) {
	return d.clientVersion, nil
}

// UTF-8 is a shortcut name for AL32UTF8 in ODPI-C (and not the same as the botched UTF8).
var cUTF8, cDriverName = ( /*line :332:26*/_Cfunc_CString /*line :332:34*/)("UTF-8"), ( /*line :332:46*/_Cfunc_CString /*line :332:54*/)(DriverName)

// initCommonCreateParams initializes ODPI-C common creation parameters used for creating pools and
// standalone connections. The C strings for the encoding and driver name are
// defined at the package level for convenience.
func (d *drv) initCommonCreateParams(P * /*line :337:41*/_Ctype_dpiCommonCreateParams /*line :337:64*/, enableEvents bool, stmtCacheSize int, charset string) error {
	// initialize ODPI-C structure for common creation parameters
	if err := d.checkExec(func()  /*line :339:31*/_Ctype_int /*line :339:36*/ {
		return func() _Ctype_int{ _cgo0 := /*line :340:46*/d.dpiContext; _cgo1 := /*line :340:60*/P; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :340:62*/_Cfunc_dpiContext_initCommonCreateParams(_cgo0, _cgo1); }()
	}); err != nil {
		return fmt.Errorf("initCommonCreateParams: %w", err)
	}

	// assign encoding and national encoding
	P.encoding, P.nencoding = cUTF8, cUTF8
	if charset != "" {
		P.encoding = ( /*line :348:16*/_Cfunc_CString /*line :348:24*/)(charset)
		P.nencoding = P.encoding
	}

	// assign driver name
	P.driverName = cDriverName
	P.driverNameLength =  /*line :354:23*/_Ctype_uint32_t /*line :354:33*/(len(DriverName))

	// assign creation mode; always use threaded mode in order to allow
	// goroutines to function without mutexing; enable events mode, if
	// requested
	P.createMode = ( /*line :359:17*/_Ciconst_DPI_MODE_CREATE_DEFAULT /*line :359:41*/) | ( /*line :359:45*/_Ciconst_DPI_MODE_CREATE_THREADED /*line :359:70*/)
	if enableEvents {
		P.createMode |= ( /*line :361:19*/_Ciconst_DPI_MODE_CREATE_EVENTS /*line :361:42*/)
	}
	if stmtCacheSize != 0 {
		if stmtCacheSize < 0 {
			P.stmtCacheSize = 0
		} else {
			P.stmtCacheSize =  /*line :367:22*/_Ctype_uint32_t /*line :367:32*/(stmtCacheSize)
		}
	}

	return nil
}

// createConn creates an ODPI-C connection with the specified parameters. If a pool is
// provided, the connection is acquired from the pool; otherwise, a standalone
// connection is created.
// second return value: true = connection is new / false = connection is from pool
func (d *drv) createConn(pool *connPool, P commonAndConnParams) (*conn, bool, error) {
	// initialize driver, if necessary
	if err := d.init(P.ConfigDir, P.LibDir); err != nil {
		return nil, false, err
	}

	dc, isNew, cleanup, err := d.acquireConn(pool, P)
	if err != nil {
		return nil, false, err
	}
	var poolKey string
	if pool != nil {
		poolKey = pool.key
	}
	// create connection and initialize it, if needed
	c := conn{
		drv: d, dpiConn: dc,
		params:   dsn.ConnectionParams{CommonParams: P.CommonParams, ConnParams: P.ConnParams},
		poolKey:  poolKey,
		objTypes: make(map[string]*ObjectType),
	}
	logger := P.Logger
	var cs * /*line :400:10*/_Ctype_char /*line :400:16*/
	var length  /*line :401:13*/_Ctype_uint /*line :401:19*/
	for _, td := range []struct {
		Name string
		Dest *string
		f    func()  /*line :405:15*/_Ctype_int /*line :405:20*/
	}{
		{"DbDomain", &c.DomainName, func()  /*line :407:38*/_Ctype_int /*line :407:43*/ { return func() _Ctype_int{ _cgo0 := /*line :407:75*/c.dpiConn; _cgoBase1 := /*line :407:86*/&cs; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :407:91*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :407:99*/_Cfunc_dpiConn_getDbDomain(_cgo0, _cgo1, _cgo2); }() }},
		{"Edition", &c.Edition, func()  /*line :408:34*/_Ctype_int /*line :408:39*/ { return func() _Ctype_int{ _cgo0 := /*line :408:70*/c.dpiConn; _cgoBase1 := /*line :408:81*/&cs; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :408:86*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :408:94*/_Cfunc_dpiConn_getEdition(_cgo0, _cgo1, _cgo2); }() }},
		{"DbName", &c.DBName, func()  /*line :409:32*/_Ctype_int /*line :409:37*/ { return func() _Ctype_int{ _cgo0 := /*line :409:67*/c.dpiConn; _cgoBase1 := /*line :409:78*/&cs; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :409:83*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :409:91*/_Cfunc_dpiConn_getDbName(_cgo0, _cgo1, _cgo2); }() }},
		{"ServiceName", &c.ServiceName, func()  /*line :410:42*/_Ctype_int /*line :410:47*/ { return func() _Ctype_int{ _cgo0 := /*line :410:82*/c.dpiConn; _cgoBase1 := /*line :410:93*/&cs; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :410:98*/&length; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :410:106*/_Cfunc_dpiConn_getServiceName(_cgo0, _cgo1, _cgo2); }() }},
	} {
		if err := c.checkExec(td.f); err != nil {
			if logger != nil {
				logger.Error(td.Name, "error", err)
			}
		} else if length != 0 && cs != nil {
			*td.Dest = ( /*line :417:15*/_Cfunc_GoStringN /*line :417:25*/)(cs,  /*line :417:31*/_Ctype_int /*line :417:36*/(length))
		}
	}

	if pool != nil {
		c.params.PoolParams = pool.params.PoolParams
		if c.params.Username == "" {
			c.params.Username = pool.params.Username
		}
	}
	ctx, cancel := context.WithTimeout(context.Background(), nvlD(c.params.WaitTimeout, time.Minute))
	err = c.init(ctx, isNew, getOnInit(&c.params.CommonParams))
	cancel()
	if err != nil {
		_ = c.closeNotLocking()
		if cleanup != nil {
			cleanup()
		}
		return nil, false, err
	}

	if !guardWithFinalizers.Load() {
		return &c, isNew, nil
	}

	if !logLingeringResourceStack.Load() {
		runtime.SetFinalizer(&c, func(c *conn) {
			if cleanup != nil {
				cleanup()
			}
			if c != nil && c.dpiConn != nil {
				fmt.Printf("ERROR: conn %p of createConn is not Closed!\n", c)
				_ = c.closeNotLocking()
			}
		})
	} else {
		var a [4096]byte
		stack := a[:runtime.Stack(a[:], false)]
		runtime.SetFinalizer(&c, func(c *conn) {
			if cleanup != nil {
				cleanup()
			}
			if c != nil && c.dpiConn != nil {
				fmt.Printf("ERROR: conn %p of createConn is not Closed!\n%s\n", c, stack)
				_ = c.closeNotLocking()
			}
		})
	}
	return &c, isNew, nil
}

func (d *drv) acquireConn(pool *connPool, P commonAndConnParams) (* /*line :468:68*/_Ctype_dpiConn /*line :468:77*/, bool, func(), error) {
	logger := P.Logger
	if logger != nil {
		logger.Debug("acquireConn", "pool", pool, "connParams", P)
	}
	// initialize ODPI-C structure for common creation parameters; this is only
	// used when a standalone connection is being created; when a connection is
	// being acquired from the pool this structure is not needed
	var commonCreateParamsPtr * /*line :476:29*/_Ctype_dpiCommonCreateParams /*line :476:52*/
	if pool == nil {
		var commonCreateParams  /*line :478:26*/_Ctype_dpiCommonCreateParams /*line :478:49*/
		if err := d.initCommonCreateParams(&commonCreateParams, P.EnableEvents, P.StmtCacheSize, P.Charset); err != nil {
			return nil, false, nil, err
		}
		commonCreateParamsPtr = &commonCreateParams
	}
	// manage strings
	var cUsername, cPassword, cNewPassword, cConnectString, cConnClass * /*line :485:70*/_Ctype_char /*line :485:76*/
	defer func() {
		if cUsername != nil {
			func() { _cgo0 := /*line :488:11*/unsafe.Pointer(cUsername); _cgoCheckPointer(_cgo0, nil); /*line :488:37*/_Cfunc_free(_cgo0); }()
		}
		if cPassword != nil {
			func() { _cgo0 := /*line :491:11*/unsafe.Pointer(cPassword); _cgoCheckPointer(_cgo0, nil); /*line :491:37*/_Cfunc_free(_cgo0); }()
		}
		if cNewPassword != nil {
			func() { _cgo0 := /*line :494:11*/unsafe.Pointer(cNewPassword); _cgoCheckPointer(_cgo0, nil); /*line :494:40*/_Cfunc_free(_cgo0); }()
		}
		if cConnectString != nil {
			func() { _cgo0 := /*line :497:11*/unsafe.Pointer(cConnectString); _cgoCheckPointer(_cgo0, nil); /*line :497:42*/_Cfunc_free(_cgo0); }()
		}
		if cConnClass != nil {
			func() { _cgo0 := /*line :500:11*/unsafe.Pointer(cConnClass); _cgoCheckPointer(_cgo0, nil); /*line :500:38*/_Cfunc_free(_cgo0); }()
		}
	}()

	// initialize ODPI-C structure for connection creation parameters
	var connCreateParams  /*line :505:23*/_Ctype_dpiConnCreateParams /*line :505:44*/
	if err := d.checkExec(func()  /*line :506:31*/_Ctype_int /*line :506:36*/ {
		return func() _Ctype_int{ _cgo0 := /*line :507:44*/d.dpiContext; _cgoBase1 := /*line :507:58*/&connCreateParams; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :507:76*/_Cfunc_dpiContext_initConnCreateParams(_cgo0, _cgo1); }()
	}); err != nil {
		return nil, false, nil, fmt.Errorf("initConnCreateParams: %w", err)
	}

	// assign connection class
	if P.ConnClass != "" {
		cConnClass = ( /*line :514:16*/_Cfunc_CString /*line :514:24*/)(P.ConnClass)
		connCreateParams.connectionClass = cConnClass
		connCreateParams.connectionClassLength =  /*line :516:44*/_Ctype_uint32_t /*line :516:54*/(len(P.ConnClass))
	}

	// assign new password (only relevant for standalone connections)
	if pool == nil && !P.NewPassword.IsZero() {
		cNewPassword = ( /*line :521:18*/_Cfunc_CString /*line :521:26*/)(P.NewPassword.Secret())
		connCreateParams.newPassword = cNewPassword
		connCreateParams.newPasswordLength =  /*line :523:40*/_Ctype_uint32_t /*line :523:50*/(P.NewPassword.Len())
	}

	// assign external authentication flag (only relevant for standalone
	// connections)
	if pool == nil && P.Username == "" && P.Password.IsZero() {
		connCreateParams.externalAuth = 1
	}

	// assign authorization mode
	connCreateParams.authMode =  /*line :533:30*/_Ctype_dpiAuthMode /*line :533:43*/(( /*line :533:44*/_Ciconst_DPI_MODE_AUTH_DEFAULT /*line :533:66*/))
	if P.IsSysDBA {
		connCreateParams.authMode |= ( /*line :535:32*/_Ciconst_DPI_MODE_AUTH_SYSDBA /*line :535:53*/)
	}
	if P.IsSysOper {
		connCreateParams.authMode |= ( /*line :538:32*/_Ciconst_DPI_MODE_AUTH_SYSOPER /*line :538:54*/)
	}
	if P.IsSysASM {
		connCreateParams.authMode |= ( /*line :541:32*/_Ciconst_DPI_MODE_AUTH_SYSASM /*line :541:53*/)
	}
	if P.IsPrelim {
		connCreateParams.authMode |= ( /*line :544:32*/_Ciconst_DPI_MODE_AUTH_PRELIM /*line :544:53*/)
	}

	var cleanup func()
	// assign sharding keys, if applicable
	if len(P.ShardingKey) > 0 {
		var tempData  /*line :550:16*/_Ctype_dpiData /*line :550:25*/
		mem := ( /*line :551:10*/_Cfunc__CMalloc /*line :551:17*/)(( /*line :551:19*/_Ciconst_sizeof_dpiShardingKeyColumn /*line :551:47*/) *
			 /*line :552:4*/_Ctype_size_t /*line :552:12*/(len(P.ShardingKey)))
		defer func() func() { _cgo0 := /*line :553:16*/mem; return func() { _cgoCheckPointer(_cgo0, nil); /*line :553:20*/_Cfunc_free(_cgo0); }}()()
		columns := (*[(math.MaxInt32 - 1) / ( /*line :554:39*/_Ciconst_sizeof_dpiShardingKeyColumn /*line :554:67*/)] /*line :554:69*/_Ctype_dpiShardingKeyColumn /*line :554:91*/)(mem)
		tbd := make([]func(), 0, len(P.ShardingKey))
		for i, value := range P.ShardingKey {
			switch value := value.(type) {
			case int:
				columns[i].oracleTypeNum = ( /*line :559:32*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :559:55*/)
				columns[i].nativeTypeNum = ( /*line :560:32*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :560:54*/)
				( /*line :561:5*/_Cfunc_dpiData_setInt64 /*line :561:22*/)(&tempData,  /*line :561:35*/_Ctype_int64_t /*line :561:44*/(value))
			case string:
				columns[i].oracleTypeNum = ( /*line :563:32*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :563:56*/)
				columns[i].nativeTypeNum = ( /*line :564:32*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :564:54*/)
				cs := ( /*line :565:11*/_Cfunc_CString /*line :565:19*/)(value)
				tbd = append(tbd, func() { func() { _cgo0 := /*line :566:39*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :566:58*/_Cfunc_free(_cgo0); }() })
				( /*line :567:5*/_Cfunc_dpiData_setBytes /*line :567:22*/)(&tempData, cs,  /*line :567:39*/_Ctype_uint32_t /*line :567:49*/(len(value)))
			case []byte:
				columns[i].oracleTypeNum = ( /*line :569:32*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :569:52*/)
				columns[i].nativeTypeNum = ( /*line :570:32*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :570:54*/)
				cs := (* /*line :571:13*/_Ctype_char /*line :571:19*/)(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :571:30*/value; _cgoCheckPointer(_cgo0, nil); return /*line :571:36*/_Cfunc_CBytes(_cgo0); }())
				tbd = append(tbd, func() { func() { _cgo0 := /*line :572:39*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :572:58*/_Cfunc_free(_cgo0); }() })
				( /*line :573:5*/_Cfunc_dpiData_setBytes /*line :573:22*/)(&tempData, cs,  /*line :573:39*/_Ctype_uint32_t /*line :573:49*/(len(value)))
			default:
				for _, f := range tbd {
					f()
				}
				return nil, false, nil, errors.New("unsupported data type for sharding")
			}
			columns[i].value = tempData.value
		}
		connCreateParams.shardingKeyColumns = &columns[0]
		connCreateParams.numShardingKeyColumns =  /*line :583:44*/_Ctype_uint8_t /*line :583:53*/(len(P.ShardingKey))
		if len(tbd) != 0 {
			cleanup = func() {
				for _, f := range tbd {
					f()
				}
			}
		}
	}

	// if a pool was provided, assign the pool
	if pool != nil {
		connCreateParams.pool = pool.dpiPool
	}

	// setup credentials
	username, password := P.Username, P.Password.Secret()
	if pool != nil && !pool.params.Heterogeneous && !pool.params.ExternalAuth {
		// Only for homogeneous pool force user, password as empty.
		username, password = "", ""
	}
	if username != "" {
		cUsername = ( /*line :605:15*/_Cfunc_CString /*line :605:23*/)(username)
	}
	if password != "" {
		cPassword = ( /*line :608:15*/_Cfunc_CString /*line :608:23*/)(password)
	}
	if P.ConnectString != "" {
		cConnectString = ( /*line :611:20*/_Cfunc_CString /*line :611:28*/)(P.ConnectString)
	}

	// create ODPI-C connection
	var dc * /*line :615:10*/_Ctype_dpiConn /*line :615:19*/
	if err := d.checkExec(func()  /*line :616:31*/_Ctype_int /*line :616:36*/ {
		return func() _Ctype_int{ _cgo0 := /*line :618:4*/d.dpiContext; var _cgo1 *_Ctype_char = /*line :619:4*/cUsername; var _cgo2 _Ctype_uint = _Ctype_uint32_t /*line :619:25*/(len(username)); var _cgo3 *_Ctype_char = /*line :620:4*/cPassword; var _cgo4 _Ctype_uint = _Ctype_uint32_t /*line :620:25*/(len(password)); var _cgo5 *_Ctype_char = /*line :621:4*/cConnectString; var _cgo6 _Ctype_uint = _Ctype_uint32_t /*line :621:30*/(len(P.ConnectString)); _cgo7 := /*line :622:4*/commonCreateParamsPtr; _cgoBase8 := /*line :623:4*/&connCreateParams; _cgo8 := _cgoBase8; _cgoBase9 := /*line :623:23*/&dc; _cgo9 := _cgoBase9; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo7, nil); _cgoCheckPointer(_cgoBase8, 0 == 0); _cgoCheckPointer(_cgoBase9, 0 == 0); return /*line :624:4*/_Cfunc_dpiConn_create(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8, _cgo9); }()
	}); err != nil {
		if cleanup != nil {
			cleanup()
		}
		if pool != nil {
			stats, _ := d.getPoolStats(pool)
			return nil, false, nil, fmt.Errorf("pool=%p stats=%s params=%+v: %w",
				pool.dpiPool, stats, connCreateParams, err)
		}
		return nil, false, nil, fmt.Errorf("user=%q standalone params=%+v: %w",
			username, connCreateParams, err)
	}
	//use the information from ODPI driver if new connection has been created or it is only pooled
	isNew := connCreateParams.outNewSession == 1
	return dc, isNew, cleanup, nil
}

// createConnFromParams creates a driver connection given pool parameters and connection
// parameters. The pool parameters are used to either create a pool or use an
// existing cached pool.
//
// If the pool parameters are nil, no pool is used and a
// standalone connection is created instead. The connection parameters are used
// to acquire a connection from the pool specified by the pool parameters or
// are used to create a standalone connection.
func (d *drv) createConnFromParams(ctx context.Context, P dsn.ConnectionParams) (*conn, error) {
	var err error
	var pool *connPool
	if !P.IsStandalone() {
		pool, err = d.getPool(commonAndPoolParams{CommonParams: P.CommonParams, PoolParams: P.PoolParams})
		if err != nil {
			return nil, err
		}
	}
	conn, isNew, err := d.createConn(pool, commonAndConnParams{CommonParams: P.CommonParams, ConnParams: P.ConnParams})
	if err != nil {
		return conn, err
	}

	if P.CommonParams.InitOnNewConn && !isNew {
		return conn, nil
	}

	onInit := getOnInit(&conn.params.CommonParams)
	if onInit == nil {
		return conn, err
	}
	ctx, cancel := context.WithTimeout(ctx, nvlD(conn.params.WaitTimeout, time.Minute))
	err = onInit(ctx, conn)
	cancel()
	if err != nil {
		conn.Close()
		return nil, err
	}
	return conn, nil
}

// getPool get the pool to use given the set of pool parameters provided.
//
// Pools are stored in a map keyed by a string representation of the pool parameters.
// If no pool exists, a pool is created and stored in the map.
func (d *drv) getPool(P commonAndPoolParams) (*connPool, error) {
	// initialize driver, if necessary
	if err := d.init(P.ConfigDir, P.LibDir); err != nil {
		return nil, err
	}

	var usernameKey string
	var passwordHash [sha256.Size]byte
	if !P.Heterogeneous && !P.ExternalAuth {
		// skip username being part of key in heterogeneous pools
		usernameKey = P.Username
		passwordHash = sha256.Sum256([]byte(P.Password.Secret())) // See issue #245
	}
	// determine key to use for pool
	poolKey := fmt.Sprintf("%s\t%x\t%s\t%d\t%d\t%d\t%s\t%s\t%s\t%t\t%t\t%t\t%s\t%d\t%s",
		usernameKey, passwordHash[:4], P.ConnectString, P.MinSessions, P.MaxSessions,
		P.SessionIncrement, P.WaitTimeout, P.MaxLifeTime, P.SessionTimeout,
		P.Heterogeneous, P.EnableEvents, P.ExternalAuth,
		P.Timezone, P.MaxSessionsPerShard, P.PingInterval,
	)
	logger := P.Logger
	if logger != nil {
		logger.Debug("getPool", "key", poolKey)
	}

	// if pool already exists, return it immediately; otherwise, create a new
	// pool; hold the lock while the pool is looked up (and created, if needed)
	// in order to ensure that multiple goroutines do not attempt to create a
	// pool
	d.mu.RLock()
	pool, ok := d.pools[poolKey]
	d.mu.RUnlock()
	if ok {
		return pool, nil
	}
	// createPool uses checkExec wich needs getError which uses RLock,
	// so we cannot Lock here, thus this little race window for
	// creating a pool and throwing it away.
	pool, err := d.createPool(P)
	if err != nil {
		return nil, err
	}
	d.mu.Lock()
	defer d.mu.Unlock()
	if poolOld, ok := d.pools[poolKey]; ok {
		_ = pool.Close()
		return poolOld, nil
	}
	pool.key = poolKey
	d.pools[poolKey] = pool
	return pool, nil
}

// createPool creates an ODPI-C pool with the specified parameters.
//
// This is done while holding the mutex in order to ensure that
// multiple goroutines do not attempt to create the pool at the same time.
func (d *drv) createPool(P commonAndPoolParams) (*connPool, error) {

	// set up common creation parameters
	var commonCreateParams  /*line :746:25*/_Ctype_dpiCommonCreateParams /*line :746:48*/
	if err := d.initCommonCreateParams(&commonCreateParams, P.EnableEvents, P.StmtCacheSize, P.Charset); err != nil {
		return nil, err
	}

	// initialize ODPI-C structure for pool creation parameters
	var poolCreateParams  /*line :752:23*/_Ctype_dpiPoolCreateParams /*line :752:44*/
	if err := d.checkExec(func()  /*line :753:31*/_Ctype_int /*line :753:36*/ {
		return func() _Ctype_int{ _cgo0 := /*line :754:44*/d.dpiContext; _cgoBase1 := /*line :754:58*/&poolCreateParams; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :754:76*/_Cfunc_dpiContext_initPoolCreateParams(_cgo0, _cgo1); }()
	}); err != nil {
		return nil, fmt.Errorf("initPoolCreateParams: %w", err)
	}

	// assign minimum number of sessions permitted in the pool
	poolCreateParams.minSessions = dsn.DefaultPoolMinSessions
	if P.MinSessions >= 0 {
		poolCreateParams.minSessions =  /*line :762:34*/_Ctype_uint32_t /*line :762:44*/(P.MinSessions)
	}

	// assign maximum number of sessions permitted in the pool
	poolCreateParams.maxSessions = dsn.DefaultPoolMaxSessions
	if P.MaxSessions > 0 {
		poolCreateParams.maxSessions =  /*line :768:34*/_Ctype_uint32_t /*line :768:44*/(P.MaxSessions)
	}

	// assign the number of sessions to create each time more is needed
	poolCreateParams.sessionIncrement = dsn.DefaultPoolIncrement
	if P.SessionIncrement > 0 {
		poolCreateParams.sessionIncrement =  /*line :774:39*/_Ctype_uint32_t /*line :774:49*/(P.SessionIncrement)
	}

	// assign "get" mode (always used timed wait)
	poolCreateParams.getMode = ( /*line :778:29*/_Ciconst_DPI_MODE_POOL_GET_TIMEDWAIT /*line :778:57*/)

	// assign wait timeout (number of milliseconds to wait for a session to
	// become available
	poolCreateParams.waitTimeout =  /*line :782:33*/_Ctype_uint32_t /*line :782:43*/(dsn.DefaultWaitTimeout / time.Millisecond)
	if P.WaitTimeout > 0 {
		poolCreateParams.waitTimeout =  /*line :784:34*/_Ctype_uint32_t /*line :784:44*/(P.WaitTimeout / time.Millisecond)
	}

	// assign timeout (number of seconds before idle pool session are evicted
	// from the pool
	poolCreateParams.timeout =  /*line :789:29*/_Ctype_uint32_t /*line :789:39*/(dsn.DefaultSessionTimeout / time.Second)
	if P.SessionTimeout > 0 {
		poolCreateParams.timeout =  /*line :791:30*/_Ctype_uint32_t /*line :791:40*/(P.SessionTimeout / time.Second)
	}

	// assign maximum lifetime (number of seconds a pooled session may exist)
	poolCreateParams.maxLifetimeSession =  /*line :795:40*/_Ctype_uint32_t /*line :795:50*/(dsn.DefaultMaxLifeTime / time.Second)
	if P.MaxLifeTime > 0 {
		poolCreateParams.maxLifetimeSession =  /*line :797:41*/_Ctype_uint32_t /*line :797:51*/(P.MaxLifeTime / time.Second)
	}

	// assign external authentication flag
	poolCreateParams.externalAuth =  /*line :801:34*/_Ctype_int /*line :801:39*/(b2i(P.ExternalAuth))

	// assign homogeneous pool flag; default is true so need to clear the flag
	// if specifically reqeuested or if external authentication is desirable
	if poolCreateParams.externalAuth == 1 || P.Heterogeneous {
		poolCreateParams.homogeneous = 0
	}

	// setup credentials
	var cUsername, cPassword, cConnectString * /*line :810:44*/_Ctype_char /*line :810:50*/
	if P.Username != "" {
		cUsername = ( /*line :812:15*/_Cfunc_CString /*line :812:23*/)(P.Username)
		defer func() func() { _cgo0 := /*line :813:16*/unsafe.Pointer(cUsername); return func() { _cgoCheckPointer(_cgo0, nil); /*line :813:42*/_Cfunc_free(_cgo0); }}()()
	}
	if !P.Password.IsZero() {
		cPassword = ( /*line :816:15*/_Cfunc_CString /*line :816:23*/)(P.Password.Secret())
		defer func() func() { _cgo0 := /*line :817:16*/unsafe.Pointer(cPassword); return func() { _cgoCheckPointer(_cgo0, nil); /*line :817:42*/_Cfunc_free(_cgo0); }}()()
	}
	if P.ConnectString != "" {
		cConnectString = ( /*line :820:20*/_Cfunc_CString /*line :820:28*/)(P.ConnectString)
		defer func() func() { _cgo0 := /*line :821:16*/unsafe.Pointer(cConnectString); return func() { _cgoCheckPointer(_cgo0, nil); /*line :821:47*/_Cfunc_free(_cgo0); }}()()
	}

	// create pool
	var dp * /*line :825:10*/_Ctype_dpiPool /*line :825:19*/
	logger := P.Logger
	if logger != nil && logger.Enabled(context.TODO(), slog.LevelDebug) {
		logger.Debug("C.dpiPool_create",
			"user", P.Username,
			"ConnectString", P.ConnectString,
			"common", commonCreateParams,
			"pool", fmt.Sprintf("%#v", poolCreateParams))
	}
	if err := d.checkExec(func()  /*line :834:31*/_Ctype_int /*line :834:36*/ {
		return func() _Ctype_int{ _cgo0 := /*line :836:4*/d.dpiContext; var _cgo1 *_Ctype_char = /*line :837:4*/cUsername; var _cgo2 _Ctype_uint = _Ctype_uint32_t /*line :837:25*/(len(P.Username)); var _cgo3 *_Ctype_char = /*line :838:4*/cPassword; var _cgo4 _Ctype_uint = _Ctype_uint32_t /*line :838:25*/(P.Password.Len()); var _cgo5 *_Ctype_char = /*line :839:4*/cConnectString; var _cgo6 _Ctype_uint = _Ctype_uint32_t /*line :839:30*/(len(P.ConnectString)); _cgoBase7 := /*line :840:4*/&commonCreateParams; _cgo7 := _cgoBase7; _cgoBase8 := /*line :841:4*/&poolCreateParams; _cgo8 := _cgoBase8; _cgoBase9 := /*line :842:33*/&dp; _cgo9 := /*line :842:4*/(**_Ctype_dpiPool /*line :842:16*/)(unsafe.Pointer(_cgoBase9)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase7, 0 == 0); _cgoCheckPointer(_cgoBase8, 0 == 0); _cgoCheckPointer(_cgoBase9, 0 == 0); return /*line :843:4*/_Cfunc_dpiPool_create(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8, _cgo9); }()
	}); err != nil {
		return nil, fmt.Errorf("dpoPool_create user=%s extAuth=%v: %w",
			P.Username, poolCreateParams.externalAuth, err)
	}

	// set statement cache
	stmtCacheSize :=  /*line :850:19*/_Ctype_uint32_t /*line :850:29*/(40)
	if P.StmtCacheSize != 0 {
		if P.StmtCacheSize < 0 {
			stmtCacheSize = 0
		} else {
			stmtCacheSize =  /*line :855:20*/_Ctype_uint32_t /*line :855:30*/(P.StmtCacheSize)
		}
	}
	func() _Ctype_int{ _cgo0 := /*line :858:29*/dp; var _cgo1 _Ctype_uint = /*line :858:33*/stmtCacheSize; _cgoCheckPointer(_cgo0, nil); return /*line :858:47*/_Cfunc_dpiPool_setStmtCacheSize(_cgo0, _cgo1); }()

	return &connPool{dpiPool: dp, params: P}, nil
}

// PoolStats contains Oracle session pool statistics
type PoolStats struct {
	Busy, Open, Max                   uint32
	MaxLifetime, Timeout, WaitTimeout time.Duration
}

func (s PoolStats) String() string {
	return fmt.Sprintf("busy=%d open=%d max=%d maxLifetime=%s timeout=%s waitTimeout=%s",
		s.Busy, s.Open, s.Max, s.MaxLifetime, s.Timeout, s.WaitTimeout)
}
func (p PoolStats) AsDBStats() sql.DBStats {
	return sql.DBStats{
		MaxOpenConnections: int(p.Max),
		// Pool Status
		OpenConnections: int(p.Open),
		InUse:           int(p.Busy),
		Idle:            int(p.Open) - int(p.Busy),
	}
}

// Stats returns PoolStats of the pool.
func (d *drv) getPoolStats(p *connPool) (stats PoolStats, err error) {
	if p == nil || p.dpiPool == nil {
		return stats, nil
	}

	stats.Max = uint32(p.params.PoolParams.MaxSessions)

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	var u  /*line :893:8*/_Ctype_uint32_t /*line :893:18*/
	if func() _Ctype_int{ _cgo0 := /*line :894:28*/p.dpiPool; var _cgo1 *_Ctype_uint32_t = /*line :894:39*/&u; _cgoCheckPointer(_cgo0, nil); return /*line :894:42*/_Cfunc_dpiPool_getBusyCount(_cgo0, _cgo1); }() != ( /*line :894:46*/_Ciconst_DPI_FAILURE /*line :894:58*/) {
		stats.Busy = uint32(u)
	}
	if func() _Ctype_int{ _cgo0 := /*line :897:28*/p.dpiPool; var _cgo1 *_Ctype_uint32_t = /*line :897:39*/&u; _cgoCheckPointer(_cgo0, nil); return /*line :897:42*/_Cfunc_dpiPool_getOpenCount(_cgo0, _cgo1); }() != ( /*line :897:46*/_Ciconst_DPI_FAILURE /*line :897:58*/) {
		stats.Open = uint32(u)
	}
	if func() _Ctype_int{ _cgo0 := /*line :900:37*/p.dpiPool; var _cgo1 *_Ctype_uint32_t = /*line :900:48*/&u; _cgoCheckPointer(_cgo0, nil); return /*line :900:51*/_Cfunc_dpiPool_getMaxLifetimeSession(_cgo0, _cgo1); }() != ( /*line :900:55*/_Ciconst_DPI_FAILURE /*line :900:67*/) {
		stats.MaxLifetime = time.Duration(u) * time.Second
	}
	if func() _Ctype_int{ _cgo0 := /*line :903:26*/p.dpiPool; var _cgo1 *_Ctype_uint32_t = /*line :903:37*/&u; _cgoCheckPointer(_cgo0, nil); return /*line :903:40*/_Cfunc_dpiPool_getTimeout(_cgo0, _cgo1); }() != ( /*line :903:44*/_Ciconst_DPI_FAILURE /*line :903:56*/) {
		stats.Timeout = time.Duration(u) * time.Second
	}
	if func() _Ctype_int{ _cgo0 := /*line :906:30*/p.dpiPool; var _cgo1 *_Ctype_uint32_t = /*line :906:41*/&u; _cgoCheckPointer(_cgo0, nil); return /*line :906:44*/_Cfunc_dpiPool_getWaitTimeout(_cgo0, _cgo1); }() != ( /*line :906:48*/_Ciconst_DPI_FAILURE /*line :906:60*/) {
		stats.WaitTimeout = time.Duration(u) * time.Millisecond
		return stats, nil
	}
	return stats, d.getError()
}

type commonAndConnParams struct {
	dsn.CommonParams
	dsn.ConnParams
}

func (P commonAndConnParams) String() string {
	return P.CommonParams.String() + " " + P.ConnParams.String()
}

type commonAndPoolParams struct {
	dsn.CommonParams
	dsn.PoolParams
}

func (P commonAndPoolParams) String() string {
	return P.CommonParams.String() + " " + P.PoolParams.String()
}

// OraErr is an error holding the ORA-01234 code and the message.
type OraErr struct {
	message, funName, action, sqlState string
	code, offset                       int
	recoverable, warning               bool
}

// AsOraErr returns the underlying *OraErr and whether it succeeded.
func AsOraErr(err error) (*OraErr, bool) {
	var oerr *OraErr
	ok := errors.As(err, &oerr)
	return oerr, ok
}

var _ error = (*OraErr)(nil)

// Code returns the OraErr's error code.
func (oe *OraErr) Code() int {
	if oe == nil {
		return 0
	}
	return oe.code
}

// Message returns the OraErr's message.
func (oe *OraErr) Message() string {
	if oe == nil {
		return ""
	}
	return oe.message
}
func (oe *OraErr) Error() string {
	if oe == nil {
		return ""
	}
	msg := oe.Message()
	if oe.code == 0 && msg == "" {
		return ""
	}
	return fmt.Sprintf("ORA-%05d: %s", oe.code, oe.message)
}
func fromErrorInfo(errInfo  /*line :972:28*/_Ctype_dpiErrorInfo /*line :972:42*/) error {
	oe := OraErr{
		code:        int(errInfo.code),
		message:     strings.TrimSpace(( /*line :975:34*/_Cfunc_GoStringN /*line :975:44*/)(errInfo.message,  /*line :975:63*/_Ctype_int /*line :975:68*/(errInfo.messageLength))),
		offset:      int(errInfo.offset),
		funName:     strings.TrimSpace(( /*line :977:34*/_Cfunc_GoString /*line :977:43*/)(errInfo.fnName)),
		action:      strings.TrimSpace(( /*line :978:34*/_Cfunc_GoString /*line :978:43*/)(errInfo.action)),
		sqlState:    strings.TrimSpace(( /*line :979:34*/_Cfunc_GoString /*line :979:43*/)(errInfo.sqlState)),
		recoverable: errInfo.isRecoverable != 0,
		warning:     errInfo.isWarning != 0,
	}
	if oe.code == 0 && oe.message == "" {
		return nil
	}
	indexNotDigit := func(s string) int {
		return strings.IndexFunc(s, func(r rune) bool {
			return !('0' <= r && r <= '9')
		})
	}
	if oe.code == 0 {
		if msg, ok := stringsCutPrefix(oe.message, "ORA-"); ok {
			if i := indexNotDigit(msg); i > 0 && msg[i] == ':' {
				if j, _ := strconv.Atoi(msg[:i]); j > 0 {
					oe.code, oe.message = j, strings.TrimSpace(msg[i+1:])
				}
			}
		}
	}
	if oe.code == 0 {
		// DPI-1080: connection was closed by ORA-3113
		if msg, num, ok := stringsCut(oe.message, " ORA-"); ok {
			if j := indexNotDigit(num); j > 0 {
				num, msg = num[:j], msg+" "+num[j:]
			}
			if j, _ := strconv.Atoi(num); j > 0 {
				oe.code, oe.message = j, strings.TrimSpace(msg)
			}
		}
	}
	oe.message = strings.TrimPrefix(oe.message, fmt.Sprintf("ORA-%05d: ", oe.Code()))
	return &oe
}

// Offset returns the parse error offset (in bytes) when executing a statement or the row offset when performing bulk operations or fetching batch error information. If neither of these cases are true, the value is 0.
func (oe *OraErr) Offset() int { return oe.offset }

// FunName returns the public ODPI-C function name which was called in which the error took place. This is a null-terminated ASCII string.
func (oe *OraErr) FunName() string { return oe.funName }

// Action returns the internal action that was being performed when the error took place. This is a null-terminated ASCII string.
func (oe *OraErr) Action() string { return oe.action }

// SQLState returns the SQLSTATE code associated with the error. This is a 5 character null-terminated string.
func (oe *OraErr) SQLState() string { return oe.sqlState }

// Recoverable indicates if the error is recoverable. This is always false unless both client and server are at release 12.1 or higher.
func (oe *OraErr) Recoverable() bool { return oe.recoverable }

func (oe *OraErr) IsWarning() bool { return oe.warning }

// newErrorInfo is just for testing: testing cannot use Cgo...
func newErrorInfo(code int, message string)  /*line :1033:45*/_Ctype_dpiErrorInfo /*line :1033:59*/ {
	return  /*line :1034:9*/_Ctype_dpiErrorInfo /*line :1034:23*/{code:  /*line :1034:30*/_Ctype_int32_t /*line :1034:39*/(code), message: ( /*line :1034:56*/_Cfunc_CString /*line :1034:64*/)(message), messageLength:  /*line :1034:91*/_Ctype_uint /*line :1034:97*/(len(message))}
}

// against deadcode
var _ = newErrorInfo

func (d *drv) getError() error {
	if d == nil {
		return &OraErr{code: 12153, message: "getError on nil drv: " + driver.ErrBadConn.Error()}
	}
	d.mu.RLock()
	dpiContext := d.dpiContext
	d.mu.RUnlock()

	if dpiContext == nil {
		return &OraErr{code: 12153, message: "getError on in dpiContext: " + driver.ErrBadConn.Error()}
	}
	var errInfo  /*line :1051:14*/_Ctype_dpiErrorInfo /*line :1051:28*/
	func() { _cgo0 := /*line :1052:24*/dpiContext; _cgoBase1 := /*line :1052:36*/&errInfo; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); /*line :1052:45*/_Cfunc_dpiContext_getError(_cgo0, _cgo1); }()
	return fromErrorInfo(errInfo)
}
func b2i(b bool) uint8 {
	if b {
		return 1
	}
	return 0
}

// VersionInfo holds version info returned by Oracle DB.
type VersionInfo struct {
	ServerRelease                                           string
	Version, Release, Update, PortRelease, PortUpdate, Full uint8
}

func (V *VersionInfo) set(v * /*line :1068:30*/_Ctype_dpiVersionInfo /*line :1068:46*/) {
	*V = VersionInfo{
		Version: uint8(v.versionNum),
		Release: uint8(v.releaseNum), Update: uint8(v.updateNum),
		PortRelease: uint8(v.portReleaseNum), PortUpdate: uint8(v.portUpdateNum),
		Full: uint8(v.fullVersionNum),
	}
}
func (V *VersionInfo) String() string {
	var s string
	if V.ServerRelease != "" {
		s = " [" + V.ServerRelease + "]"
	}
	return fmt.Sprintf("%d.%d.%d.%d.%d%s", V.Version, V.Release, V.Update, V.PortRelease, V.PortUpdate, s)
}

var timezones = make(map[string]*time.Location)
var timezonesMu sync.RWMutex

func timeZoneFor(hourOffset, minuteOffset  /*line :1087:43*/_Ctype_int8_t /*line :1087:51*/, local *time.Location) *time.Location {
	if hourOffset == 0 && minuteOffset == 0 {
		if local == nil {
			return time.UTC
		}
		return local
	}
	var tS string
	if local != nil {
		tS = local.String()
	}
	key := fmt.Sprintf("%02d:%02d\t%s", hourOffset, minuteOffset, tS)
	timezonesMu.RLock()
	tz, ok := timezones[key]
	timezonesMu.RUnlock()
	if ok {
		return tz
	}
	timezonesMu.Lock()
	defer timezonesMu.Unlock()
	if tz, ok = timezones[key]; ok {
		return tz
	}
	off := int(hourOffset)*3600 + int(minuteOffset)*60
	if local != nil {
		if _, localOff := time.Now().In(local).Zone(); off == localOff {
			tz = local
		}
	}
	if tz == nil {
		tz = time.FixedZone(key[:5], off)
	}
	timezones[key] = tz
	return tz
}

var _ driver.DriverContext = (*drv)(nil)
var _ driver.Connector = (*connector)(nil)
var _ io.Closer = (*connector)(nil)

type connector struct {
	drv *drv
	dsn.ConnectionParams
}

// NewConnector returns a driver.Connector to be used with sql.OpenDB
//
// ConnectionParams must be complete, so start with what ParseDSN returns!
func (d *drv) NewConnector(params dsn.ConnectionParams) driver.Connector {
	return connector{drv: d, ConnectionParams: params}
}

// NewConnector returns a driver.Connector to be used with sql.OpenDB,
// (for the default Driver registered with godror)
//
// ConnectionParams must be complete, so start with what ParseDSN returns!
func NewConnector(params dsn.ConnectionParams) driver.Connector {
	return defaultDrv.NewConnector(params)
}

// OpenConnector must parse the name in the same format that Driver.Open
// parses the name parameter.
func (d *drv) OpenConnector(name string) (driver.Connector, error) {

	// parse connection string
	P, err := dsn.Parse(name)
	if err != nil {
		return nil, err
	}

	return NewConnector(P), nil
}

// Connect returns a connection to the database.
// Connect may return a cached connection (one previously
// closed), but doing so is unnecessary; the sql package
// maintains a pool of idle connections for efficient re-use.
//
// The provided context.Context is for dialing purposes only
// (see net.DialContext) and should not be stored or used for
// other purposes.
//
// The returned connection is only used by one goroutine at a
// time.
func (c connector) Connect(ctx context.Context) (driver.Conn, error) {
	params := c.ConnectionParams
	logger := c.CommonParams.Logger
	if ctxValue := ctx.Value(paramsCtxKey{}); ctxValue != nil {
		if cc, ok := ctxValue.(commonAndConnParams); ok {
			// ContextWithUserPassw does not fill ConnParam.ConnectString
			if cc.ConnectString == "" {
				cc.ConnectString = params.ConnectString
			}
			logger = cc.Logger
			if logger != nil {
				logger.Debug("connect with params from context", "poolParams", params.PoolParams, "connParams", cc, "common", cc.CommonParams)
			}
			return c.drv.createConnFromParams(ctx, dsn.ConnectionParams{
				CommonParams: cc.CommonParams, ConnParams: cc.ConnParams,
				PoolParams: params.PoolParams,
			})
		}
	}

	if ctxValue := ctx.Value(userPasswCtxKey{}); ctxValue != nil {
		if up, ok := ctxValue.(UserPasswdConnClassTag); ok {
			params.CommonParams.Username = up.Username
			params.CommonParams.Password = up.Password
			params.ConnParams.ConnClass = up.ConnClass
		}
	}

	if logger != nil {
		logger.Debug("connect", "poolParams", params.PoolParams, "connParams", params.ConnParams, "common", params.CommonParams)
	}
	return c.drv.createConnFromParams(ctx, params)
}

// Driver returns the underlying Driver of the Connector,
// mainly to maintain compatibility with the Driver method
// on sql.DB.
func (c connector) Driver() driver.Driver { return c.drv }

// Close the connector's underlying driver.
//
// From Go 1.17 sql.DB.Close() will call this method.
func (c connector) Close() error {
	if c.drv == nil || c.drv == defaultDrv {
		return nil
	}
	return c.drv.Close()
}

// NewSessionIniter returns a function suitable for use in NewConnector as onInit,
//
// Deprecated. Use ParseDSN + ConnectionParams.SetSessionParamOnInit and NewConnector.
// which calls "ALTER SESSION SET <key>='<value>'" for each element of the given map.
func NewSessionIniter(m map[string]string) func(context.Context, driver.ConnPrepareContext) error {
	var buf strings.Builder
	buf.WriteString("ALTER SESSION SET ")
	for k, v := range m {
		buf.WriteByte(' ')
		fmt.Fprintf(&buf, "%s=q'(%s)'", k, strings.Replace(v, "'", "''", -1))
	}
	return mkExecMany([]string{buf.String()})
}
func getOnInit(P *CommonParams) func(context.Context, driver.ConnPrepareContext) error {
	if P.OnInit != nil {
		return P.OnInit
	}
	stmts := P.OnInitStmts
	stmts = stmts[:len(stmts):len(stmts)]
	if len(P.AlterSession) != 0 {
		var buf strings.Builder
		buf.WriteString("ALTER SESSION SET")
		for _, kv := range P.AlterSession {
			buf.WriteByte(' ')
			buf.WriteString(kv[0])
			buf.WriteByte('=')
			if strings.EqualFold(kv[0], "CURRENT_SCHEMA") {
				buf.WriteString(kv[1])
			} else {
				buf.WriteByte('\'')
				buf.WriteString(strings.Replace(kv[1], "'", "''", -1))
				buf.WriteByte('\'')
			}
		}
		stmts = append(stmts, buf.String())
	}
	if len(stmts) == 0 {
		return nil
	}

	P.OnInit = mkExecMany(stmts)
	return P.OnInit
}

// mkExecMany returns a function that applies the queries to the connection.
func mkExecMany(qrys []string) func(context.Context, driver.ConnPrepareContext) error {
	return func(ctx context.Context, conn driver.ConnPrepareContext) error {
		logger := getLogger(ctx)
		for _, qry := range qrys {
			if logger != nil {
				logger.Debug("execMany", "qry", qry)
			}
			st, err := conn.PrepareContext(ctx, qry)
			if err == nil {
				_, err = st.(driver.StmtExecContext).ExecContext(ctx, nil)
				st.Close()
			}
			if err != nil {
				return fmt.Errorf("%s: %w", qry, err)
			}
		}
		return nil
	}
}

func nvlD(a, b time.Duration) time.Duration {
	if a == 0 {
		return b
	}
	return a
}

var logLingeringResourceStack atomic.Bool

// LogLingeringResourceStack sets whether to log the lingering resource's (allocation) stack in Finalizer.
// Default is to not log, as it consumes a few kiB for each resource (stmt, conn, queue, object type).
//
// Should not cause problem with bug-free program, that closes all stmt's ASAP.
//
// For programs that'd benefit this stack, enabling it may raise memory consumption
// significantly over time. So enable it only for debugging!
func LogLingeringResourceStack(b bool) { logLingeringResourceStack.Store(b) }

var guardWithFinalizers atomic.Bool

// GuardWithFinalizers sets whether we should guard resources with Finalizers.
func GuardWithFinalizers(b bool) { guardWithFinalizers.Store(b) }
